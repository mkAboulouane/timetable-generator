<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ADVANCED_FEATURES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ADVANCED_FEATURES.md" />
              <option name="updatedContent" value="#  Advanced Timetabling System - Feature Overview&#10;&#10;This document outlines the important features that have been added to make this timetabling script significantly more helpful for real-world scheduling scenarios.&#10;&#10;##  New Features Added&#10;&#10;### 1. **Advanced Scheduling Preferences &amp; Soft Constraints** &#10;*File: `timetable_preferences.py`*&#10;&#10;**What it does:**&#10;- Allows specification of teacher preferred time slots&#10;- Supports lunch break preservation&#10;- Enables compact schedule preferences (minimize gaps)&#10;- Avoids late evening classes&#10;- Provides weighted preference system&#10;&#10;**Why it's important:**&#10;- Real schedules aren't just about feasibility - quality matters&#10;- Teachers have preferences for when they want to teach&#10;- Students prefer compact schedules without large gaps&#10;- Administrators want to avoid unpopular time slots&#10;&#10;**Example usage:**&#10;```json&#10;{&#10;  &quot;preferences&quot;: {&#10;    &quot;teacher_preferences&quot;: [&#10;      {&#10;        &quot;teacher_id&quot;: &quot;T_MATH&quot;, &#10;        &quot;preferred_slots&quot;: [&quot;Mon_08-10&quot;, &quot;Tue_08-10&quot;],&#10;        &quot;weight&quot;: 0.7&#10;      }&#10;    ],&#10;    &quot;lunch_break&quot;: {&#10;      &quot;start_time&quot;: &quot;12:00&quot;,&#10;      &quot;end_time&quot;: &quot;14:00&quot;, &#10;      &quot;weight&quot;: 0.8&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### 2. **Conflict Detection and Resolution System**&#10;*File: `timetable_conflicts.py`*&#10;&#10;**What it does:**&#10;- Detects 10 different types of scheduling conflicts&#10;- Provides detailed conflict analysis with severity levels&#10;- Suggests specific solutions for each conflict type&#10;- Identifies capacity violations, availability issues, and double bookings&#10;&#10;**Why it's important:**&#10;- Helps understand WHY a schedule fails&#10;- Provides actionable suggestions to fix problems&#10;- Prevents silent failures and mysterious &quot;no solution&quot; results&#10;- Enables debugging of complex scheduling scenarios&#10;&#10;**Conflict types detected:**&#10;- Teacher/Room/Group double bookings&#10;- Capacity exceeded&#10;- Availability violations  &#10;- Duration mismatches&#10;- Insufficient weekly hours&#10;- Excessive daily loads&#10;&#10;### 3. **Schedule Validation and Quality Metrics**&#10;*File: `timetable_validation.py`*&#10;&#10;**What it does:**&#10;- Provides comprehensive quality scoring (0-100%)&#10;- Analyzes 8 different quality metrics&#10;- Generates recommendations for improvement&#10;- Identifies schedule strengths and weaknesses&#10;&#10;**Quality metrics:**&#10;- Constraint adherence&#10;- Resource utilization&#10;- Time distribution evenness&#10;- Workload balance&#10;- Schedule compactness&#10;- Room efficiency&#10;- Teacher satisfaction&#10;- Student convenience&#10;&#10;**Why it's important:**&#10;- Not all feasible schedules are good schedules&#10;- Provides objective quality assessment&#10;- Helps compare different scheduling solutions&#10;- Identifies areas for improvement&#10;&#10;### 4. **Backup and Recovery System**&#10;*File: `timetable_backup.py`*&#10;&#10;**What it does:**&#10;- Automatic backup creation before/after solving&#10;- Version control for timetable configurations&#10;- Easy restore from any backup point&#10;- Backup cleanup and management&#10;&#10;**Why it's important:**&#10;- Prevents loss of work when experimenting&#10;- Enables &quot;undo&quot; functionality&#10;- Supports iterative schedule development&#10;- Provides safety net for production systems&#10;&#10;**Features:**&#10;- Automatic timestamped backups&#10;- Metadata tracking&#10;- One-click restore&#10;- Cleanup of old backups&#10;&#10;### 5. **Enhanced Export Capabilities**&#10;*File: `timetable_enhanced_export.py`*&#10;&#10;**What it does:**&#10;- Exports to 7+ different formats&#10;- Integration with external systems&#10;- Statistical reporting&#10;- Calendar format support&#10;&#10;**Supported formats:**&#10;- **CSV** - For spreadsheets and analysis&#10;- **iCal** - For Outlook/Google Calendar import&#10;- **XML** - Structured data exchange&#10;- **Moodle** - Course management integration&#10;- **Teams** - Microsoft Teams meeting setup&#10;- **Enhanced JSON** - With statistics and metadata&#10;- **Statistics Report** - Detailed analytics&#10;&#10;**Why it's important:**&#10;- Real institutions use diverse systems&#10;- Enables integration with existing workflows&#10;- Provides data for external analysis&#10;- Supports different stakeholder needs&#10;&#10;### 6. **Automatic HTML Generation**&#10;*Already implemented in main agent*&#10;&#10;**What it does:**&#10;- Automatically creates visual timetables after solving&#10;- No manual export step required&#10;- Immediate visual feedback&#10;&#10;### 7. **Enhanced Problem Diagnosis**&#10;*Integrated into main system*&#10;&#10;**What it does:**&#10;- Detailed analysis of why problems are unsolvable&#10;- Identifies events with zero initial domains&#10;- Provides specific constraint violation details&#10;&#10;##  Key Benefits&#10;&#10;### For Administrators:&#10;- **Quality Assessment** - Know how good your schedule is objectively&#10;- **Conflict Resolution** - Understand exactly what's wrong and how to fix it&#10;- **Export Flexibility** - Get schedules in whatever format you need&#10;- **Backup Safety** - Never lose work, always able to go back&#10;&#10;### For Technical Users:&#10;- **Advanced Preferences** - Fine-tune schedules beyond just feasibility&#10;- **Debugging Tools** - Understand complex constraint interactions&#10;- **Integration Support** - Connect with existing systems&#10;- **Extensible Architecture** - Easy to add new features&#10;&#10;### For End Users:&#10;- **Better Schedules** - Higher quality results with fewer gaps and conflicts&#10;- **Visual Output** - Immediate HTML visualization&#10;- **Multiple Formats** - Calendar imports, spreadsheets, etc.&#10;- **Reliability** - Automatic backups prevent data loss&#10;&#10;##  Usage Examples&#10;&#10;### Basic Usage (Original):&#10;```python&#10;solve_from_json(&quot;input.json&quot;, &quot;output.json&quot;)&#10;```&#10;&#10;### Advanced Usage (New):&#10;```python&#10;solve_from_json_advanced(&#10;    &quot;input.json&quot;, &#10;    &quot;output.json&quot;,&#10;    enable_validation=True,     # Quality analysis&#10;    enable_backup=True,         # Auto backups  &#10;    export_formats=['csv', 'ical', 'stats']  # Multiple exports&#10;)&#10;```&#10;&#10;### Manual Analysis:&#10;```python&#10;from timetable_conflicts import ConflictDetector&#10;from timetable_validation import ScheduleValidator&#10;&#10;# Analyze conflicts&#10;detector = ConflictDetector(problem)&#10;conflicts = detector.analyze_schedule(assignment)&#10;&#10;# Assess quality&#10;validator = ScheduleValidator(problem) &#10;report = validator.validate_and_assess(assignment)&#10;```&#10;&#10;##  Implementation Notes&#10;&#10;### Graceful Degradation:&#10;- All advanced features are optional&#10;- System falls back to basic functionality if advanced modules aren't available&#10;- No breaking changes to existing functionality&#10;&#10;### Performance:&#10;- Advanced features add minimal overhead&#10;- Validation and conflict detection are fast&#10;- Export operations run in parallel where possible&#10;&#10;### Extensibility:&#10;- Modular architecture makes adding new features easy&#10;- Each feature is self-contained&#10;- Clear APIs for custom extensions&#10;&#10;##  Impact on Real-World Usage&#10;&#10;### Before (Basic System):&#10;- ❌ &quot;No solution found&quot; with no explanation&#10;- ❌ No quality assessment of results&#10;- ❌ Single output format only&#10;- ❌ No backup/recovery&#10;- ❌ Hard to debug complex scenarios&#10;&#10;### After (Enhanced System):&#10;- ✅ Detailed conflict analysis and solutions&#10;- ✅ Comprehensive quality scoring and recommendations  &#10;- ✅ 7+ export formats for any system integration&#10;- ✅ Automatic backups with version control&#10;- ✅ Full debugging and diagnostic tools&#10;- ✅ Preference-based optimization&#10;- ✅ Professional reporting and analytics&#10;&#10;##  Next Steps&#10;&#10;### Potential Future Enhancements:&#10;1. **Machine Learning Integration** - Learn from past scheduling decisions&#10;2. **Web Interface** - Browser-based schedule creation and editing&#10;3. **Real-time Collaboration** - Multiple users editing simultaneously  &#10;4. **Mobile App** - View and minor edits from mobile devices&#10;5. **Advanced Algorithms** - Genetic algorithms, simulated annealing&#10;6. **Integration APIs** - REST APIs for system integration&#10;7. **Custom Reporting** - User-defined report templates&#10;&#10;### Getting Started:&#10;1. Use `solve_from_json_advanced()` for new projects&#10;2. Add preferences to your input JSON for better results&#10;3. Enable validation to understand schedule quality&#10;4. Use backup system for safety during development&#10;5. Export to multiple formats for stakeholder distribution&#10;&#10;This enhanced system transforms a basic scheduling tool into a comprehensive timetabling solution suitable for real-world educational institutions and organizations." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_agent.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_agent.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Timetabling agent (feasible schedule) WITHOUT modifying problem_solving_agent.py.&#10;&#10;Weeks constraint (flexible):&#10;- Each Event has a set of active weeks: event.weeks (FrozenSet[int]).&#10;- A resource conflict (teacher/group/room) occurs only if:&#10;  same timeslot AND weeks sets intersect.&#10;&#10;Hard constraints:&#10;- teacher availability (weekly pattern) + no teacher conflict (weeks-aware)&#10;- group availability (weekly pattern) + no group conflict (weeks-aware)&#10;- room availability (weekly pattern) + no room conflict (weeks-aware)&#10;- room capacity &gt;= max(sum(group sizes), module min_room_capacity)&#10;- timeslot duration == event duration&#10;&#10;Input/Output handled by timetable_io.py (JSON v3 with weeks as list/ranges/all).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, FrozenSet, List, Optional, Tuple&#10;from collections import deque&#10;import heapq&#10;&#10;from problem_solving_agent import Problem&#10;&#10;# ==========================================================&#10;# Search trace / graph export (optional)&#10;# ==========================================================&#10;&#10;try:&#10;    from search_graph import SearchGraphRecorder&#10;except Exception:  # pragma: no cover&#10;    SearchGraphRecorder = None  # type: ignore&#10;&#10;&#10;# ==========================================================&#10;# Data model&#10;# ==========================================================&#10;&#10;@dataclass(frozen=True)&#10;class TimeSlot:&#10;    id: str&#10;    day: str&#10;    start: str&#10;    end: str&#10;    duration_min: int&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Group:&#10;    id: str&#10;    size: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Room:&#10;    id: str&#10;    capacity: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Teacher:&#10;    id: str&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Event:&#10;    id: str&#10;    teacher_id: str&#10;    group_ids: Tuple[str, ...]&#10;    duration_min: int&#10;    allowed_slots: Optional[FrozenSet[str]] = None&#10;&#10;    # From module/session structure (input JSON)&#10;    min_room_capacity: int = 0&#10;    session_id: str = &quot;&quot;&#10;    module_id: str = &quot;&quot;&#10;&#10;    # Module hours per week (informational, from module config)&#10;    module_hours_per_week: float = 0.0&#10;&#10;    # Active weeks for this event (e.g., {1,3,5} or weeks from ranges)&#10;    weeks: FrozenSet[int] = frozenset()&#10;&#10;&#10;# State: tuple of assignments (event_id, timeslot_id, room_id) sorted by event_id&#10;AssignmentTuple = Tuple[Tuple[str, str, str], ...]&#10;&#10;&#10;# ==========================================================&#10;# Weeks logic&#10;# ==========================================================&#10;&#10;def weeks_intersect(a: FrozenSet[int], b: FrozenSet[int]) -&gt; bool:&#10;    &quot;&quot;&quot;True if week sets intersect.&quot;&quot;&quot;&#10;    return not a.isdisjoint(b)&#10;&#10;&#10;# ==========================================================&#10;# Helpers&#10;# ==========================================================&#10;&#10;def event_demand(e: Event, groups: Dict[str, Group]) -&gt; int:&#10;    return sum(groups[gid].size for gid in e.group_ids)&#10;&#10;&#10;def is_room_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    r_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, r) in assignment:&#10;        if t != t_id or r != r_id:&#10;            continue&#10;        existing = events[eid]&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_teacher_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    teacher_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if existing.teacher_id != teacher_id:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_group_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    group_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if group_id not in existing.group_ids:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;# ==========================================================&#10;# Problem definition&#10;# ==========================================================&#10;&#10;class TimetablingProblem(Problem):&#10;    &quot;&quot;&quot;&#10;    Feasible scheduling problem with hard constraints only, using week-sets.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        initial_state: AssignmentTuple,&#10;        goal: Any = None,&#10;        *,&#10;        events: List[Event],&#10;        timeslots: List[TimeSlot],&#10;        rooms: List[Room],&#10;        teachers: List[Teacher],&#10;        groups: List[Group],&#10;        use_mrv: bool = True,&#10;    ):&#10;        super().__init__(initial_state, goal)&#10;&#10;        self.use_mrv = use_mrv&#10;&#10;        self.events_list = events&#10;        self.timeslots_list = timeslots&#10;        self.rooms_list = rooms&#10;        self.teachers_list = teachers&#10;        self.groups_list = groups&#10;&#10;        self.events: Dict[str, Event] = {e.id: e for e in events}&#10;        self.timeslots: Dict[str, TimeSlot] = {t.id: t for t in timeslots}&#10;        self.rooms: Dict[str, Room] = {r.id: r for r in rooms}&#10;        self.teachers: Dict[str, Teacher] = {t.id: t for t in teachers}&#10;        self.groups: Dict[str, Group] = {g.id: g for g in groups}&#10;&#10;        self.all_event_ids: Tuple[str, ...] = tuple(e.id for e in events)&#10;&#10;        # Precompute compatible rooms per event:&#10;        # room.capacity &gt;= max(demand, min_room_capacity)&#10;        self.compatible_rooms: Dict[str, Tuple[str, ...]] = {}&#10;        for e in events:&#10;            dem = event_demand(e, self.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            self.compatible_rooms[e.id] = tuple(r.id for r in rooms if r.capacity &gt;= required)&#10;&#10;        # Precompute compatible slots per event:&#10;        # duration + teacher availability + all groups availability (+ allowed_slots)&#10;        self.compatible_slots: Dict[str, Tuple[str, ...]] = {}&#10;        all_slot_ids = set(self.timeslots.keys())&#10;&#10;        for e in events:&#10;            duration_slots = {t.id for t in timeslots if t.duration_min == e.duration_min}&#10;            teacher_av = set(self.teachers[e.teacher_id].available)&#10;&#10;            group_av = set(all_slot_ids)&#10;            for gid in e.group_ids:&#10;                group_av &amp;= set(self.groups[gid].available)&#10;&#10;            slots = duration_slots &amp; teacher_av &amp; group_av&#10;&#10;            # Handle allowed_slots with support for ALL/all macro&#10;            if e.allowed_slots is not None:&#10;                allowed_set = set()&#10;                for slot in e.allowed_slots:&#10;                    if slot.upper() == &quot;ALL&quot;:&#10;                        # &quot;ALL&quot; or &quot;all&quot; means all available timeslots&#10;                        allowed_set = all_slot_ids&#10;                        break&#10;                    else:&#10;                        allowed_set.add(slot)&#10;                slots &amp;= allowed_set&#10;&#10;            self.compatible_slots[e.id] = tuple(sorted(slots))&#10;&#10;    def _unassigned(self, state: AssignmentTuple) -&gt; List[str]:&#10;        assigned = {eid for (eid, _, _) in state}&#10;        return [eid for eid in self.all_event_ids if eid not in assigned]&#10;&#10;    def _select_next_event(self, state: AssignmentTuple) -&gt; Optional[str]:&#10;        unassigned = self._unassigned(state)&#10;        if not unassigned:&#10;            return None&#10;&#10;        if not self.use_mrv:&#10;            return unassigned[0]&#10;&#10;        # MRV: smallest estimated domain size slots*rooms&#10;        best_eid = None&#10;        best_size = None&#10;        for eid in unassigned:&#10;            size = len(self.compatible_slots[eid]) * len(self.compatible_rooms[eid])&#10;            if best_eid is None or size &lt; best_size:&#10;                best_eid, best_size = eid, size&#10;        return best_eid&#10;&#10;    def actions(self, state: AssignmentTuple) -&gt; List[Tuple[str, str, str]]:&#10;        &quot;&quot;&quot;&#10;        Actions are (event_id, timeslot_id, room_id).&#10;        We generate actions only for the next event (MRV) to keep branching manageable.&#10;        &quot;&quot;&quot;&#10;        eid = self._select_next_event(state)&#10;        if eid is None:&#10;            return []&#10;&#10;        e = self.events[eid]&#10;        acts: List[Tuple[str, str, str]] = []&#10;&#10;        for t_id in self.compatible_slots[eid]:&#10;            # teacher conflict (weeks-aware)&#10;            if not is_teacher_free(state, self.events, t_id, e.teacher_id, e):&#10;                continue&#10;&#10;            # group conflicts (weeks-aware)&#10;            if any(not is_group_free(state, self.events, t_id, gid, e) for gid in e.group_ids):&#10;                continue&#10;&#10;            for r_id in self.compatible_rooms[eid]:&#10;                room = self.rooms[r_id]&#10;&#10;                # room availability (weekly pattern)&#10;                if t_id not in room.available:&#10;                    continue&#10;&#10;                # room conflict (weeks-aware)&#10;                if not is_room_free(state, self.events, t_id, r_id, e):&#10;                    continue&#10;&#10;                acts.append((eid, t_id, r_id))&#10;&#10;        return acts&#10;&#10;    def result(self, state: AssignmentTuple, action: Tuple[str, str, str]) -&gt; AssignmentTuple:&#10;        eid, t_id, r_id = action&#10;        new_state = list(state) + [(eid, t_id, r_id)]&#10;        new_state.sort(key=lambda x: x[0])  # canonical&#10;        return tuple(new_state)&#10;&#10;    def goal_test(self, state: AssignmentTuple) -&gt; bool:&#10;        return len(state) == len(self.all_event_ids)&#10;&#10;    def path_cost(self, cost_so_far: float, state1: Any, action: Any, state2: Any) -&gt; float:&#10;        return cost_so_far + 1.0&#10;&#10;&#10;# ==========================================================&#10;# Search algorithms (no Trace dependency)&#10;# ==========================================================&#10;&#10;import time&#10;&#10;@dataclass&#10;class SearchResult:&#10;    &quot;&quot;&quot;Result of a search algorithm with statistics.&quot;&quot;&quot;&#10;    path: Optional[List[Any]]&#10;    iterations: int&#10;    nodes_explored: int&#10;    max_frontier_size: int&#10;    final_cost: float&#10;    elapsed_time: float&#10;    algorithm: str&#10;&#10;&#10;def reconstruct_path(parents: Dict[Any, Any], start: Any, goal: Any) -&gt; List[Any]:&#10;    path = [goal]&#10;    cur = goal&#10;    while cur != start:&#10;        cur = parents[cur]&#10;        path.append(cur)&#10;    path.reverse()&#10;    return path&#10;&#10;&#10;def state_repr(state: AssignmentTuple, max_items: int = 3) -&gt; str:&#10;    &quot;&quot;&quot;Compact representation of state for console output.&quot;&quot;&quot;&#10;    if len(state) == 0:&#10;        return &quot;(empty)&quot;&#10;    if len(state) &lt;= max_items:&#10;        return str(list(state))&#10;    return f&quot;[{len(state)} assignments: {list(state[:max_items])}...]&quot;&#10;&#10;&#10;def dfs_search(&#10;    problem: TimetablingProblem,&#10;    verbose: bool = True,&#10;    *,&#10;    record_graph: bool = False,&#10;    algorithm_label: str = &quot;DFS&quot;,&#10;):&#10;    algo_name = algorithm_label&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = [start]&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set()&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    recorder = None&#10;    if record_graph:&#10;        if SearchGraphRecorder is None:&#10;            raise RuntimeError(&#10;                &quot;Graph recording requested but 'search_graph.py' could not be imported.&quot;&#10;            )&#10;        recorder = SearchGraphRecorder(algorithm=algo_name)&#10;        recorder.mark_start(start, label=f&quot;{state_repr(start)}\nstart&quot;)&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.pop()&#10;&#10;        actions_list = problem.actions(state)&#10;&#10;        if recorder is not None:&#10;            recorder.add_iteration(&#10;                iteration=iteration,&#10;                current_state=state,&#10;                frontier_size=len(frontier),&#10;                explored_size=len(visited),&#10;                cost=float(len(state)),&#10;                actions_count=len(actions_list),&#10;                current_label=f&quot;{state_repr(state)}\niter={iteration} f={len(frontier)} e={len(visited)}&quot;,&#10;            )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if recorder is not None:&#10;                recorder.mark_goal(state, label=f&quot;{state_repr(state)}\nGOAL&quot;)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            result = SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name,&#10;            )&#10;            # Attach recorder if present (non-breaking: just set attribute)&#10;            if recorder is not None:&#10;                setattr(result, &quot;graph&quot;, recorder)&#10;            return result&#10;&#10;        if state in visited:&#10;            continue&#10;        visited.add(state)&#10;&#10;        for action in actions_list:&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                parents[child] = state&#10;                frontier.append(child)&#10;                if recorder is not None:&#10;                    recorder.add_edge(&#10;                        state,&#10;                        child,&#10;                        parent_label=state_repr(state),&#10;                        child_label=state_repr(child),&#10;                        attrs={&quot;label&quot;: str(action)},&#10;                    )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(actions_list)}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    result = SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name,&#10;    )&#10;    if recorder is not None:&#10;        setattr(result, &quot;graph&quot;, recorder)&#10;    return result&#10;&#10;&#10;def bfs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;BFS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = deque([start])&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set([start])&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 1 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.popleft()&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                visited.add(child)&#10;                parents[child] = state&#10;                frontier.append(child)&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def ucs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;UCS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(0.0, start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        g, state = heapq.heappop(frontier)&#10;&#10;        if g != best_g.get(state, float(&quot;inf&quot;)):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g, child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def h_zero(state: AssignmentTuple) -&gt; float:&#10;    return 0.0&#10;&#10;&#10;def a_star_search(problem: TimetablingProblem, h=h_zero, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;A*&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(h(start), start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial g=0.0, h={h(start)}, f={h(start)}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        f, state = heapq.heappop(frontier)&#10;        g = best_g[state]&#10;&#10;        if f != g + h(state):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}, h(n): {h(state)}, f(n): {f}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g + h(child), child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;# ==========================================================&#10;# Output formatting&#10;# ==========================================================&#10;&#10;def _weeks_to_ranges(weeks: FrozenSet[int]) -&gt; str:&#10;    &quot;&quot;&quot;Compact printing: 1,3,5,7,10,16 or 1-6,10-14 style.&quot;&quot;&quot;&#10;    if not weeks:&#10;        return &quot;&quot;&#10;    w = sorted(weeks)&#10;    ranges = []&#10;    start = prev = w[0]&#10;    for x in w[1:]:&#10;        if x == prev + 1:&#10;            prev = x&#10;            continue&#10;        ranges.append((start, prev))&#10;        start = prev = x&#10;    ranges.append((start, prev))&#10;    return &quot;,&quot;.join([f&quot;{a}-{b}&quot; if a != b else f&quot;{a}&quot; for a, b in ranges])&#10;&#10;&#10;def pretty_print_schedule(problem: TimetablingProblem, assignment: AssignmentTuple):&#10;    print(&quot;\n================= SCHEDULE =================&quot;)&#10;&#10;    def key_fn(x):&#10;        eid, tid, _ = x&#10;        ts = problem.timeslots[tid]&#10;        return (ts.day, ts.start, eid)&#10;&#10;    for eid, tid, rid in sorted(assignment, key=key_fn):&#10;        e = problem.events[eid]&#10;        ts = problem.timeslots[tid]&#10;        dem = event_demand(e, problem.groups)&#10;        cap = problem.rooms[rid].capacity&#10;        required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;&#10;        print(&#10;            f&quot;- {ts.day} {ts.start}-{ts.end} | event={eid} | teacher={e.teacher_id} &quot;&#10;            f&quot;| groups={list(e.group_ids)} | room={rid} | required={required}/{cap} &quot;&#10;            f&quot;| weeks={_weeks_to_ranges(e.weeks)} | session={e.session_id} module={e.module_id}&quot;&#10;        )&#10;&#10;    print(&quot;===========================================\n&quot;)&#10;&#10;&#10;&#10;def diagnose_domains(problem: TimetablingProblem, limit: int = 50):&#10;    &quot;&quot;&quot;&#10;    Prints events that have 0 possible actions from the INITIAL state,&#10;    i.e. no (timeslot, room) satisfies availability + capacity constraints&#10;    (without considering conflicts with other events).&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n========== DIAGNOSE: INITIAL DOMAINS ==========&quot;)&#10;    bad = 0&#10;    for e in problem.events_list:&#10;        slots = problem.compatible_slots.get(e.id, ())&#10;        rooms = problem.compatible_rooms.get(e.id, ())&#10;        domain_size = len(slots) * len(rooms)&#10;        if domain_size == 0:&#10;            bad += 1&#10;            dem = event_demand(e, problem.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            print(f&quot;- EVENT {e.id} | teacher={e.teacher_id} | session={e.session_id} module={e.module_id}&quot;)&#10;            print(f&quot;  groups={list(e.group_ids)} demand={dem} min_room_capacity={e.min_room_capacity} required={required}&quot;)&#10;            print(f&quot;  compatible_slots={list(slots)}&quot;)&#10;            print(f&quot;  compatible_rooms={list(rooms)}&quot;)&#10;            if bad &gt;= limit:&#10;                print(f&quot;... (stopping after {limit} zero-domain events)&quot;)&#10;                break&#10;    if bad == 0:&#10;        print(&quot;✅ All events have a non-empty initial domain (before conflicts).&quot;)&#10;    else:&#10;        print(f&quot;❌ Found {bad} events with empty initial domain.&quot;)&#10;    print(&quot;=============================================\n&quot;)&#10;&#10;# ==========================================================&#10;# Main solve entry (JSON in/out)&#10;# ==========================================================&#10;&#10;def _generate_html_timetable(json_path: str, config: Dict[str, Any]):&#10;    &quot;&quot;&quot;Generate HTML timetable automatically after JSON export.&quot;&quot;&quot;&#10;    try:&#10;        from timetable_export import load_output_json, generate_html_timetable&#10;        import os&#10;&#10;        # Generate HTML filename from JSON filename&#10;        base_name = os.path.splitext(json_path)[0]&#10;        html_path = f&quot;{base_name}.html&quot;&#10;&#10;        # Load the JSON data&#10;        data = load_output_json(json_path)&#10;&#10;        # Generate HTML timetable&#10;        generate_html_timetable(data, html_path)&#10;&#10;        print(f&quot; Auto-generated HTML: {html_path}&quot;)&#10;        print(&quot;    Open the HTML file in a browser to view the visual timetable.&quot;)&#10;&#10;        # Check if we have multiple sessions, offer session-based export&#10;        assignments = data.get(&quot;assignments&quot;, [])&#10;        sessions = set(a.get(&quot;session_id&quot;, &quot;unknown&quot;) for a in assignments)&#10;&#10;        if len(sessions) &gt; 1:&#10;            print(f&quot;    Multiple sessions detected ({len(sessions)} sessions)&quot;)&#10;            print(f&quot;    Run: python timetable_export.py {json_path} --by-session&quot;)&#10;            print(&quot;      to generate separate timetables per session.&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;⚠️  Failed to generate HTML: {e}&quot;)&#10;        print(&quot;   You can manually generate it with:&quot;)&#10;        print(f&quot;   python timetable_export.py {json_path}&quot;)&#10;&#10;&#10;def print_comparison_table(results: List[SearchResult]):&#10;    &quot;&quot;&quot;Print a comparison table of all search algorithms.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;  COMPARAISON DES ALGORITHMES DE RECHERCHE&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    print(f&quot;{'Algorithme':&lt;12} {'Statut':&lt;12} {'Itérations':&lt;12} {'Explorés':&lt;12} {'Max Frontière':&lt;15} {'Coût Final':&lt;12} {'Temps (s)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 100)&#10;&#10;    for r in results:&#10;        status = &quot;✅ Succès&quot; if r.path is not None else &quot;❌ Échec&quot;&#10;        cost_str = f&quot;{r.final_cost:.1f}&quot; if r.final_cost != float('inf') else &quot;∞&quot;&#10;        print(f&quot;{r.algorithm:&lt;12} {status:&lt;12} {r.iterations:&lt;12} {r.nodes_explored:&lt;12} {r.max_frontier_size:&lt;15} {cost_str:&lt;12} {r.elapsed_time:&lt;12.4f}&quot;)&#10;&#10;    print(&quot;=&quot; * 100)&#10;    print()&#10;&#10;&#10;def solve_from_json(input_path: str, output_path: str, compare_all: bool = True, auto_html: bool = True):&#10;    from timetable_io import load_input_json, export_output_json&#10;    import os&#10;&#10;    config, problem = load_input_json(input_path)&#10;    diagnose_domains(problem)&#10;&#10;    if compare_all:&#10;        # Run all 4 algorithms and compare results&#10;        print(&quot;\n&quot; + &quot;#&quot; * 100)&#10;        print(&quot;  EXÉCUTION DE TOUS LES ALGORITHMES POUR COMPARAISON&quot;)&#10;        print(&quot;#&quot; * 100)&#10;&#10;        results: List[SearchResult] = []&#10;&#10;        # DFS&#10;        result_dfs = dfs_search(problem, verbose=True)&#10;        results.append(result_dfs)&#10;&#10;        # BFS&#10;        result_bfs = bfs_search(problem, verbose=True)&#10;        results.append(result_bfs)&#10;&#10;        # UCS&#10;        result_ucs = ucs_search(problem, verbose=True)&#10;        results.append(result_ucs)&#10;&#10;        # A*&#10;        result_astar = a_star_search(problem, h_zero, verbose=True)&#10;        results.append(result_astar)&#10;&#10;        # Print comparison table&#10;        print_comparison_table(results)&#10;&#10;        # Use first successful result for output&#10;        best_result = None&#10;        for r in results:&#10;            if r.path is not None:&#10;                best_result = r&#10;                break&#10;&#10;        if best_result is None:&#10;            print(&quot;❌ Aucun algorithme n'a trouvé de solution.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=&quot;compare_all&quot;,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = best_result.path[-1]&#10;        print(f&quot;✅ Meilleur résultat avec {best_result.algorithm}: {len(final_state)} événements planifiés&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=best_result.algorithm.lower(),&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        if auto_html:&#10;            _generate_html_timetable(output_path, config)&#10;&#10;    else:&#10;        # Original behavior: run only the specified strategy&#10;        strategy = str(config.get(&quot;strategy&quot;, &quot;dfs&quot;)).lower()&#10;&#10;        if strategy == &quot;dfs&quot;:&#10;            result = dfs_search(problem, verbose=True)&#10;        elif strategy == &quot;bfs&quot;:&#10;            result = bfs_search(problem, verbose=True)&#10;        elif strategy == &quot;ucs&quot;:&#10;            result = ucs_search(problem, verbose=True)&#10;        elif strategy in (&quot;astar&quot;, &quot;a*&quot;, &quot;a_star&quot;):&#10;            result = a_star_search(problem, h_zero, verbose=True)&#10;            strategy = &quot;a_star&quot;&#10;        else:&#10;            raise ValueError(f&quot;Unknown strategy '{strategy}'. Use one of: dfs, bfs, ucs, astar&quot;)&#10;&#10;        if result.path is None:&#10;            print(&quot;❌ No feasible schedule found.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=strategy,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = result.path[-1]&#10;        print(f&quot;✅ Feasible schedule found. events_scheduled={len(final_state)}/{len(problem.events_list)}&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=strategy,&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        if auto_html:&#10;            _generate_html_timetable(output_path, config)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    solve_from_json(&quot;test/09_real_world_scenario.json&quot;, &quot;timetable_output.json&quot;, compare_all=False)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Timetabling agent (feasible schedule) WITHOUT modifying problem_solving_agent.py.&#10;&#10;Weeks constraint (flexible):&#10;- Each Event has a set of active weeks: event.weeks (FrozenSet[int]).&#10;- A resource conflict (teacher/group/room) occurs only if:&#10;  same timeslot AND weeks sets intersect.&#10;&#10;Hard constraints:&#10;- teacher availability (weekly pattern) + no teacher conflict (weeks-aware)&#10;- group availability (weekly pattern) + no group conflict (weeks-aware)&#10;- room availability (weekly pattern) + no room conflict (weeks-aware)&#10;- room capacity &gt;= max(sum(group sizes), module min_room_capacity)&#10;- timeslot duration == event duration&#10;&#10;Input/Output handled by timetable_io.py (JSON v3 with weeks as list/ranges/all).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, FrozenSet, List, Optional, Tuple&#10;from collections import deque&#10;import heapq&#10;import json&#10;from datetime import datetime&#10;&#10;from problem_solving_agent import Problem&#10;&#10;# ==========================================================&#10;# Search trace / graph export (optional)&#10;# ==========================================================&#10;&#10;try:&#10;    from search_graph import SearchGraphRecorder&#10;except Exception:  # pragma: no cover&#10;    SearchGraphRecorder = None  # type: ignore&#10;&#10;&#10;# ==========================================================&#10;# Data model&#10;# ==========================================================&#10;&#10;@dataclass(frozen=True)&#10;class TimeSlot:&#10;    id: str&#10;    day: str&#10;    start: str&#10;    end: str&#10;    duration_min: int&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Group:&#10;    id: str&#10;    size: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Room:&#10;    id: str&#10;    capacity: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Teacher:&#10;    id: str&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Event:&#10;    id: str&#10;    teacher_id: str&#10;    group_ids: Tuple[str, ...]&#10;    duration_min: int&#10;    allowed_slots: Optional[FrozenSet[str]] = None&#10;&#10;    # From module/session structure (input JSON)&#10;    min_room_capacity: int = 0&#10;    session_id: str = &quot;&quot;&#10;    module_id: str = &quot;&quot;&#10;&#10;    # Module hours per week (informational, from module config)&#10;    module_hours_per_week: float = 0.0&#10;&#10;    # Active weeks for this event (e.g., {1,3,5} or weeks from ranges)&#10;    weeks: FrozenSet[int] = frozenset()&#10;&#10;&#10;# State: tuple of assignments (event_id, timeslot_id, room_id) sorted by event_id&#10;AssignmentTuple = Tuple[Tuple[str, str, str], ...]&#10;&#10;&#10;# ==========================================================&#10;# Weeks logic&#10;# ==========================================================&#10;&#10;def weeks_intersect(a: FrozenSet[int], b: FrozenSet[int]) -&gt; bool:&#10;    &quot;&quot;&quot;True if week sets intersect.&quot;&quot;&quot;&#10;    return not a.isdisjoint(b)&#10;&#10;&#10;# ==========================================================&#10;# Helpers&#10;# ==========================================================&#10;&#10;def event_demand(e: Event, groups: Dict[str, Group]) -&gt; int:&#10;    return sum(groups[gid].size for gid in e.group_ids)&#10;&#10;&#10;def is_room_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    r_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, r) in assignment:&#10;        if t != t_id or r != r_id:&#10;            continue&#10;        existing = events[eid]&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_teacher_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    teacher_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if existing.teacher_id != teacher_id:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_group_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    group_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if group_id not in existing.group_ids:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;# ==========================================================&#10;# Problem definition&#10;# ==========================================================&#10;&#10;class TimetablingProblem(Problem):&#10;    &quot;&quot;&quot;&#10;    Feasible scheduling problem with hard constraints only, using week-sets.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        initial_state: AssignmentTuple,&#10;        goal: Any = None,&#10;        *,&#10;        events: List[Event],&#10;        timeslots: List[TimeSlot],&#10;        rooms: List[Room],&#10;        teachers: List[Teacher],&#10;        groups: List[Group],&#10;        use_mrv: bool = True,&#10;    ):&#10;        super().__init__(initial_state, goal)&#10;&#10;        self.use_mrv = use_mrv&#10;&#10;        self.events_list = events&#10;        self.timeslots_list = timeslots&#10;        self.rooms_list = rooms&#10;        self.teachers_list = teachers&#10;        self.groups_list = groups&#10;&#10;        self.events: Dict[str, Event] = {e.id: e for e in events}&#10;        self.timeslots: Dict[str, TimeSlot] = {t.id: t for t in timeslots}&#10;        self.rooms: Dict[str, Room] = {r.id: r for r in rooms}&#10;        self.teachers: Dict[str, Teacher] = {t.id: t for t in teachers}&#10;        self.groups: Dict[str, Group] = {g.id: g for g in groups}&#10;&#10;        self.all_event_ids: Tuple[str, ...] = tuple(e.id for e in events)&#10;&#10;        # Precompute compatible rooms per event:&#10;        # room.capacity &gt;= max(demand, min_room_capacity)&#10;        self.compatible_rooms: Dict[str, Tuple[str, ...]] = {}&#10;        for e in events:&#10;            dem = event_demand(e, self.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            self.compatible_rooms[e.id] = tuple(r.id for r in rooms if r.capacity &gt;= required)&#10;&#10;        # Precompute compatible slots per event:&#10;        # duration + teacher availability + all groups availability (+ allowed_slots)&#10;        self.compatible_slots: Dict[str, Tuple[str, ...]] = {}&#10;        all_slot_ids = set(self.timeslots.keys())&#10;&#10;        for e in events:&#10;            duration_slots = {t.id for t in timeslots if t.duration_min == e.duration_min}&#10;            teacher_av = set(self.teachers[e.teacher_id].available)&#10;&#10;            group_av = set(all_slot_ids)&#10;            for gid in e.group_ids:&#10;                group_av &amp;= set(self.groups[gid].available)&#10;&#10;            slots = duration_slots &amp; teacher_av &amp; group_av&#10;&#10;            # Handle allowed_slots with support for ALL/all macro&#10;            if e.allowed_slots is not None:&#10;                allowed_set = set()&#10;                for slot in e.allowed_slots:&#10;                    if slot.upper() == &quot;ALL&quot;:&#10;                        # &quot;ALL&quot; or &quot;all&quot; means all available timeslots&#10;                        allowed_set = all_slot_ids&#10;                        break&#10;                    else:&#10;                        allowed_set.add(slot)&#10;                slots &amp;= allowed_set&#10;&#10;            self.compatible_slots[e.id] = tuple(sorted(slots))&#10;&#10;    def _unassigned(self, state: AssignmentTuple) -&gt; List[str]:&#10;        assigned = {eid for (eid, _, _) in state}&#10;        return [eid for eid in self.all_event_ids if eid not in assigned]&#10;&#10;    def _select_next_event(self, state: AssignmentTuple) -&gt; Optional[str]:&#10;        unassigned = self._unassigned(state)&#10;        if not unassigned:&#10;            return None&#10;&#10;        if not self.use_mrv:&#10;            return unassigned[0]&#10;&#10;        # MRV: smallest estimated domain size slots*rooms&#10;        best_eid = None&#10;        best_size = None&#10;        for eid in unassigned:&#10;            size = len(self.compatible_slots[eid]) * len(self.compatible_rooms[eid])&#10;            if best_eid is None or size &lt; best_size:&#10;                best_eid, best_size = eid, size&#10;        return best_eid&#10;&#10;    def actions(self, state: AssignmentTuple) -&gt; List[Tuple[str, str, str]]:&#10;        &quot;&quot;&quot;&#10;        Actions are (event_id, timeslot_id, room_id).&#10;        We generate actions only for the next event (MRV) to keep branching manageable.&#10;        &quot;&quot;&quot;&#10;        eid = self._select_next_event(state)&#10;        if eid is None:&#10;            return []&#10;&#10;        e = self.events[eid]&#10;        acts: List[Tuple[str, str, str]] = []&#10;&#10;        for t_id in self.compatible_slots[eid]:&#10;            # teacher conflict (weeks-aware)&#10;            if not is_teacher_free(state, self.events, t_id, e.teacher_id, e):&#10;                continue&#10;&#10;            # group conflicts (weeks-aware)&#10;            if any(not is_group_free(state, self.events, t_id, gid, e) for gid in e.group_ids):&#10;                continue&#10;&#10;            for r_id in self.compatible_rooms[eid]:&#10;                room = self.rooms[r_id]&#10;&#10;                # room availability (weekly pattern)&#10;                if t_id not in room.available:&#10;                    continue&#10;&#10;                # room conflict (weeks-aware)&#10;                if not is_room_free(state, self.events, t_id, r_id, e):&#10;                    continue&#10;&#10;                acts.append((eid, t_id, r_id))&#10;&#10;        return acts&#10;&#10;    def result(self, state: AssignmentTuple, action: Tuple[str, str, str]) -&gt; AssignmentTuple:&#10;        eid, t_id, r_id = action&#10;        new_state = list(state) + [(eid, t_id, r_id)]&#10;        new_state.sort(key=lambda x: x[0])  # canonical&#10;        return tuple(new_state)&#10;&#10;    def goal_test(self, state: AssignmentTuple) -&gt; bool:&#10;        return len(state) == len(self.all_event_ids)&#10;&#10;    def path_cost(self, cost_so_far: float, state1: Any, action: Any, state2: Any) -&gt; float:&#10;        return cost_so_far + 1.0&#10;&#10;&#10;# ==========================================================&#10;# Search algorithms (no Trace dependency)&#10;# ==========================================================&#10;&#10;import time&#10;&#10;@dataclass&#10;class SearchResult:&#10;    &quot;&quot;&quot;Result of a search algorithm with statistics.&quot;&quot;&quot;&#10;    path: Optional[List[Any]]&#10;    iterations: int&#10;    nodes_explored: int&#10;    max_frontier_size: int&#10;    final_cost: float&#10;    elapsed_time: float&#10;    algorithm: str&#10;&#10;&#10;def reconstruct_path(parents: Dict[Any, Any], start: Any, goal: Any) -&gt; List[Any]:&#10;    path = [goal]&#10;    cur = goal&#10;    while cur != start:&#10;        cur = parents[cur]&#10;        path.append(cur)&#10;    path.reverse()&#10;    return path&#10;&#10;&#10;def state_repr(state: AssignmentTuple, max_items: int = 3) -&gt; str:&#10;    &quot;&quot;&quot;Compact representation of state for console output.&quot;&quot;&quot;&#10;    if len(state) == 0:&#10;        return &quot;(empty)&quot;&#10;    if len(state) &lt;= max_items:&#10;        return str(list(state))&#10;    return f&quot;[{len(state)} assignments: {list(state[:max_items])}...]&quot;&#10;&#10;&#10;def dfs_search(&#10;    problem: TimetablingProblem,&#10;    verbose: bool = True,&#10;    *,&#10;    record_graph: bool = False,&#10;    algorithm_label: str = &quot;DFS&quot;,&#10;):&#10;    algo_name = algorithm_label&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = [start]&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set()&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    recorder = None&#10;    if record_graph:&#10;        if SearchGraphRecorder is None:&#10;            raise RuntimeError(&#10;                &quot;Graph recording requested but 'search_graph.py' could not be imported.&quot;&#10;            )&#10;        recorder = SearchGraphRecorder(algorithm=algo_name)&#10;        recorder.mark_start(start, label=f&quot;{state_repr(start)}\nstart&quot;)&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.pop()&#10;&#10;        actions_list = problem.actions(state)&#10;&#10;        if recorder is not None:&#10;            recorder.add_iteration(&#10;                iteration=iteration,&#10;                current_state=state,&#10;                frontier_size=len(frontier),&#10;                explored_size=len(visited),&#10;                cost=float(len(state)),&#10;                actions_count=len(actions_list),&#10;                current_label=f&quot;{state_repr(state)}\niter={iteration} f={len(frontier)} e={len(visited)}&quot;,&#10;            )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if recorder is not None:&#10;                recorder.mark_goal(state, label=f&quot;{state_repr(state)}\nGOAL&quot;)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            result = SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name,&#10;            )&#10;            # Attach recorder if present (non-breaking: just set attribute)&#10;            if recorder is not None:&#10;                setattr(result, &quot;graph&quot;, recorder)&#10;            return result&#10;&#10;        if state in visited:&#10;            continue&#10;        visited.add(state)&#10;&#10;        for action in actions_list:&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                parents[child] = state&#10;                frontier.append(child)&#10;                if recorder is not None:&#10;                    recorder.add_edge(&#10;                        state,&#10;                        child,&#10;                        parent_label=state_repr(state),&#10;                        child_label=state_repr(child),&#10;                        attrs={&quot;label&quot;: str(action)},&#10;                    )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(actions_list)}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    result = SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name,&#10;    )&#10;    if recorder is not None:&#10;        setattr(result, &quot;graph&quot;, recorder)&#10;    return result&#10;&#10;&#10;def bfs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;BFS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = deque([start])&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set([start])&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 1 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.popleft()&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                visited.add(child)&#10;                parents[child] = state&#10;                frontier.append(child)&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def ucs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;UCS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(0.0, start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        g, state = heapq.heappop(frontier)&#10;&#10;        if g != best_g.get(state, float(&quot;inf&quot;)):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g, child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def h_zero(state: AssignmentTuple) -&gt; float:&#10;    return 0.0&#10;&#10;&#10;def a_star_search(problem: TimetablingProblem, h=h_zero, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;A*&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(h(start), start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial g=0.0, h={h(start)}, f={h(start)}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        f, state = heapq.heappop(frontier)&#10;        g = best_g[state]&#10;&#10;        if f != g + h(state):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}, h(n): {h(state)}, f(n): {f}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g + h(child), child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;# ==========================================================&#10;# Output formatting&#10;# ==========================================================&#10;&#10;def _weeks_to_ranges(weeks: FrozenSet[int]) -&gt; str:&#10;    &quot;&quot;&quot;Compact printing: 1,3,5,7,10,16 or 1-6,10-14 style.&quot;&quot;&quot;&#10;    if not weeks:&#10;        return &quot;&quot;&#10;    w = sorted(weeks)&#10;    ranges = []&#10;    start = prev = w[0]&#10;    for x in w[1:]:&#10;        if x == prev + 1:&#10;            prev = x&#10;            continue&#10;        ranges.append((start, prev))&#10;        start = prev = x&#10;    ranges.append((start, prev))&#10;    return &quot;,&quot;.join([f&quot;{a}-{b}&quot; if a != b else f&quot;{a}&quot; for a, b in ranges])&#10;&#10;&#10;def pretty_print_schedule(problem: TimetablingProblem, assignment: AssignmentTuple):&#10;    print(&quot;\n================= SCHEDULE =================&quot;)&#10;&#10;    def key_fn(x):&#10;        eid, tid, _ = x&#10;        ts = problem.timeslots[tid]&#10;        return (ts.day, ts.start, eid)&#10;&#10;    for eid, tid, rid in sorted(assignment, key=key_fn):&#10;        e = problem.events[eid]&#10;        ts = problem.timeslots[tid]&#10;        dem = event_demand(e, problem.groups)&#10;        cap = problem.rooms[rid].capacity&#10;        required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;&#10;        print(&#10;            f&quot;- {ts.day} {ts.start}-{ts.end} | event={eid} | teacher={e.teacher_id} &quot;&#10;            f&quot;| groups={list(e.group_ids)} | room={rid} | required={required}/{cap} &quot;&#10;            f&quot;| weeks={_weeks_to_ranges(e.weeks)} | session={e.session_id} module={e.module_id}&quot;&#10;        )&#10;&#10;    print(&quot;===========================================\n&quot;)&#10;&#10;&#10;&#10;def diagnose_domains(problem: TimetablingProblem, limit: int = 50):&#10;    &quot;&quot;&quot;&#10;    Prints events that have 0 possible actions from the INITIAL state,&#10;    i.e. no (timeslot, room) satisfies availability + capacity constraints&#10;    (without considering conflicts with other events).&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n========== DIAGNOSE: INITIAL DOMAINS ==========&quot;)&#10;    bad = 0&#10;    for e in problem.events_list:&#10;        slots = problem.compatible_slots.get(e.id, ())&#10;        rooms = problem.compatible_rooms.get(e.id, ())&#10;        domain_size = len(slots) * len(rooms)&#10;        if domain_size == 0:&#10;            bad += 1&#10;            dem = event_demand(e, problem.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            print(f&quot;- EVENT {e.id} | teacher={e.teacher_id} | session={e.session_id} module={e.module_id}&quot;)&#10;            print(f&quot;  groups={list(e.group_ids)} demand={dem} min_room_capacity={e.min_room_capacity} required={required}&quot;)&#10;            print(f&quot;  compatible_slots={list(slots)}&quot;)&#10;            print(f&quot;  compatible_rooms={list(rooms)}&quot;)&#10;            if bad &gt;= limit:&#10;                print(f&quot;... (stopping after {limit} zero-domain events)&quot;)&#10;                break&#10;    if bad == 0:&#10;        print(&quot;✅ All events have a non-empty initial domain (before conflicts).&quot;)&#10;    else:&#10;        print(f&quot;❌ Found {bad} events with empty initial domain.&quot;)&#10;    print(&quot;=============================================\n&quot;)&#10;&#10;# ==========================================================&#10;# Main solve entry (JSON in/out)&#10;# ==========================================================&#10;&#10;def _generate_html_timetable(json_path: str, config: Dict[str, Any]):&#10;    &quot;&quot;&quot;Generate HTML timetable automatically after JSON export.&quot;&quot;&quot;&#10;    try:&#10;        from timetable_export import load_output_json, generate_html_timetable&#10;        import os&#10;&#10;        # Generate HTML filename from JSON filename&#10;        base_name = os.path.splitext(json_path)[0]&#10;        html_path = f&quot;{base_name}.html&quot;&#10;&#10;        # Load the JSON data&#10;        data = load_output_json(json_path)&#10;&#10;        # Generate HTML timetable&#10;        generate_html_timetable(data, html_path)&#10;&#10;        print(f&quot; Auto-generated HTML: {html_path}&quot;)&#10;        print(&quot;    Open the HTML file in a browser to view the visual timetable.&quot;)&#10;&#10;        # Check if we have multiple sessions, offer session-based export&#10;        assignments = data.get(&quot;assignments&quot;, [])&#10;        sessions = set(a.get(&quot;session_id&quot;, &quot;unknown&quot;) for a in assignments)&#10;&#10;        if len(sessions) &gt; 1:&#10;            print(f&quot;    Multiple sessions detected ({len(sessions)} sessions)&quot;)&#10;            print(f&quot;    Run: python timetable_export.py {json_path} --by-session&quot;)&#10;            print(&quot;      to generate separate timetables per session.&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;⚠️  Failed to generate HTML: {e}&quot;)&#10;        print(&quot;   You can manually generate it with:&quot;)&#10;        print(f&quot;   python timetable_export.py {json_path}&quot;)&#10;&#10;&#10;def print_comparison_table(results: List[SearchResult]):&#10;    &quot;&quot;&quot;Print a comparison table of all search algorithms.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;  COMPARAISON DES ALGORITHMES DE RECHERCHE&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    print(f&quot;{'Algorithme':&lt;12} {'Statut':&lt;12} {'Itérations':&lt;12} {'Explorés':&lt;12} {'Max Frontière':&lt;15} {'Coût Final':&lt;12} {'Temps (s)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 100)&#10;&#10;    for r in results:&#10;        status = &quot;✅ Succès&quot; if r.path is not None else &quot;❌ Échec&quot;&#10;        cost_str = f&quot;{r.final_cost:.1f}&quot; if r.final_cost != float('inf') else &quot;∞&quot;&#10;        print(f&quot;{r.algorithm:&lt;12} {status:&lt;12} {r.iterations:&lt;12} {r.nodes_explored:&lt;12} {r.max_frontier_size:&lt;15} {cost_str:&lt;12} {r.elapsed_time:&lt;12.4f}&quot;)&#10;&#10;    print(&quot;=&quot; * 100)&#10;    print()&#10;&#10;&#10;def solve_from_json(input_path: str, output_path: str, compare_all: bool = True, auto_html: bool = True):&#10;    from timetable_io import load_input_json, export_output_json&#10;    import os&#10;&#10;    config, problem = load_input_json(input_path)&#10;    diagnose_domains(problem)&#10;&#10;    if compare_all:&#10;        # Run all 4 algorithms and compare results&#10;        print(&quot;\n&quot; + &quot;#&quot; * 100)&#10;        print(&quot;  EXÉCUTION DE TOUS LES ALGORITHMES POUR COMPARAISON&quot;)&#10;        print(&quot;#&quot; * 100)&#10;&#10;        results: List[SearchResult] = []&#10;&#10;        # DFS&#10;        result_dfs = dfs_search(problem, verbose=True)&#10;        results.append(result_dfs)&#10;&#10;        # BFS&#10;        result_bfs = bfs_search(problem, verbose=True)&#10;        results.append(result_bfs)&#10;&#10;        # UCS&#10;        result_ucs = ucs_search(problem, verbose=True)&#10;        results.append(result_ucs)&#10;&#10;        # A*&#10;        result_astar = a_star_search(problem, h_zero, verbose=True)&#10;        results.append(result_astar)&#10;&#10;        # Print comparison table&#10;        print_comparison_table(results)&#10;&#10;        # Use first successful result for output&#10;        best_result = None&#10;        for r in results:&#10;            if r.path is not None:&#10;                best_result = r&#10;                break&#10;&#10;        if best_result is None:&#10;            print(&quot;❌ Aucun algorithme n'a trouvé de solution.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=&quot;compare_all&quot;,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = best_result.path[-1]&#10;        print(f&quot;✅ Meilleur résultat avec {best_result.algorithm}: {len(final_state)} événements planifiés&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=best_result.algorithm.lower(),&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        if auto_html:&#10;            _generate_html_timetable(output_path, config)&#10;&#10;    else:&#10;        # Original behavior: run only the specified strategy&#10;        strategy = str(config.get(&quot;strategy&quot;, &quot;dfs&quot;)).lower()&#10;&#10;        if strategy == &quot;dfs&quot;:&#10;            result = dfs_search(problem, verbose=True)&#10;        elif strategy == &quot;bfs&quot;:&#10;            result = bfs_search(problem, verbose=True)&#10;        elif strategy == &quot;ucs&quot;:&#10;            result = ucs_search(problem, verbose=True)&#10;        elif strategy in (&quot;astar&quot;, &quot;a*&quot;, &quot;a_star&quot;):&#10;            result = a_star_search(problem, h_zero, verbose=True)&#10;            strategy = &quot;a_star&quot;&#10;        else:&#10;            raise ValueError(f&quot;Unknown strategy '{strategy}'. Use one of: dfs, bfs, ucs, astar&quot;)&#10;&#10;        if result.path is None:&#10;            print(&quot;❌ No feasible schedule found.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=strategy,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = result.path[-1]&#10;        print(f&quot;✅ Feasible schedule found. events_scheduled={len(final_state)}/{len(problem.events_list)}&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=strategy,&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        if auto_html:&#10;            _generate_html_timetable(output_path, config)&#10;&#10;&#10;def solve_from_json_advanced(input_path: str, output_path: str,&#10;                           compare_all: bool = True, auto_html: bool = True,&#10;                           enable_validation: bool = True, enable_backup: bool = True,&#10;                           export_formats: List[str] = None):&#10;    &quot;&quot;&quot;&#10;    Enhanced solve function with advanced features:&#10;    - Conflict detection and analysis&#10;    - Quality validation and scoring&#10;    - Automatic backup creation&#10;    - Multiple export formats&#10;    - Preference-based optimization&#10;    &quot;&quot;&quot;&#10;    from timetable_io import load_input_json, export_output_json&#10;    import os&#10;&#10;    if not ADVANCED_FEATURES:&#10;        print(&quot;⚠️ Advanced features not available, falling back to basic solve&quot;)&#10;        return solve_from_json(input_path, output_path, compare_all, auto_html)&#10;&#10;    # Create backup if enabled&#10;    backup_manager = None&#10;    if enable_backup:&#10;        backup_manager = TimetableBackupManager()&#10;        backup_version = backup_manager.create_backup(&#10;            input_path, output_path,&#10;            f&quot;Pre-solve backup - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&quot;&#10;        )&#10;        print(f&quot; Created backup: {backup_version}&quot;)&#10;&#10;    # Load configuration and create problem&#10;    config, problem = load_input_json(input_path)&#10;&#10;    # Enhanced domain diagnosis with conflict detection&#10;    print(&quot;\n ENHANCED PROBLEM ANALYSIS&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    diagnose_domains(problem)&#10;&#10;    # Load preferences if available&#10;    preferences = None&#10;    if &quot;preferences&quot; in config:&#10;        preferences = load_preferences_from_json(config[&quot;preferences&quot;])&#10;        print(f&quot;✅ Loaded {len(preferences.preferences)} scheduling preferences&quot;)&#10;&#10;    # Solve the problem&#10;    if compare_all:&#10;        print(&quot;\n&quot; + &quot;#&quot; * 100)&#10;        print(&quot;  EXÉCUTION DE TOUS LES ALGORITHMES POUR COMPARAISON&quot;)&#10;        print(&quot;#&quot; * 100)&#10;&#10;        results: List[SearchResult] = []&#10;&#10;        # Run all algorithms&#10;        result_dfs = dfs_search(problem, verbose=True)&#10;        results.append(result_dfs)&#10;&#10;        result_bfs = bfs_search(problem, verbose=True)&#10;        results.append(result_bfs)&#10;&#10;        result_ucs = ucs_search(problem, verbose=True)&#10;        results.append(result_ucs)&#10;&#10;        result_astar = a_star_search(problem, h_zero, verbose=True)&#10;        results.append(result_astar)&#10;&#10;        print_comparison_table(results)&#10;&#10;        # Select best result (prefer DFS if multiple succeed)&#10;        best_result = None&#10;        for r in results:&#10;            if r.path is not None:&#10;                best_result = r&#10;                break&#10;&#10;        if best_result is None:&#10;            print(&quot;❌ Aucun algorithme n'a trouvé de solution.&quot;)&#10;&#10;            # Analyze why no solution was found&#10;            conflict_detector = ConflictDetector(problem)&#10;            conflicts = conflict_detector.analyze_schedule([])  # Empty schedule analysis&#10;            if conflicts:&#10;                print(&quot;\n CONFLICT ANALYSIS&quot;)&#10;                print(generate_conflict_report(conflicts))&#10;&#10;            export_output_json(&#10;                output_path, config=config, problem=problem,&#10;                final_state=None, status=&quot;failure&quot;, strategy=&quot;compare_all&quot;&#10;            )&#10;            return None&#10;&#10;        final_state: AssignmentTuple = best_result.path[-1]&#10;        print(f&quot;✅ Meilleur résultat avec {best_result.algorithm}: {len(final_state)} événements planifiés&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=best_result.algorithm.lower(),&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        if auto_html:&#10;            _generate_html_timetable(output_path, config)&#10;&#10;    else:&#10;        # Single algorithm mode&#10;        strategy = str(config.get(&quot;strategy&quot;, &quot;dfs&quot;)).lower()&#10;&#10;        if strategy == &quot;dfs&quot;:&#10;            result = dfs_search(problem, verbose=True)&#10;        elif strategy == &quot;bfs&quot;:&#10;            result = bfs_search(problem, verbose=True)&#10;        elif strategy == &quot;ucs&quot;:&#10;            result = ucs_search(problem, verbose=True)&#10;        elif strategy in (&quot;astar&quot;, &quot;a*&quot;, &quot;a_star&quot;):&#10;            result = a_star_search(problem, h_zero, verbose=True)&#10;            strategy = &quot;a_star&quot;&#10;        else:&#10;            raise ValueError(f&quot;Unknown strategy '{strategy}'. Use one of: dfs, bfs, ucs, astar&quot;)&#10;&#10;        if result.path is None:&#10;            print(&quot;❌ No feasible schedule found.&quot;)&#10;&#10;            # Analyze conflicts&#10;            conflict_detector = ConflictDetector(problem)&#10;            conflicts = conflict_detector.analyze_schedule([])&#10;            if conflicts:&#10;                print(&quot;\n CONFLICT ANALYSIS&quot;)&#10;                print(generate_conflict_report(conflicts))&#10;&#10;            export_output_json(&#10;                output_path, config=config, problem=problem,&#10;                final_state=None, status=&quot;failure&quot;, strategy=strategy&#10;            )&#10;            return None&#10;&#10;        final_state: AssignmentTuple = result.path[-1]&#10;        best_result = result&#10;        print(f&quot;✅ Feasible schedule found. events_scheduled={len(final_state)}/{len(problem.events_list)}&quot;)&#10;&#10;    # Display basic schedule&#10;    pretty_print_schedule(problem, final_state)&#10;&#10;    # Advanced validation and quality analysis&#10;    conflicts = []&#10;    quality_report = None&#10;    &#10;    if enable_validation:&#10;        print(&quot;\n ADVANCED SCHEDULE ANALYSIS&quot;)&#10;        print(&quot;=&quot; * 50)&#10;        &#10;        # Conflict detection&#10;        conflict_detector = ConflictDetector(problem)&#10;        conflicts = conflict_detector.analyze_schedule(final_state)&#10;        &#10;        if conflicts:&#10;            print(&quot; CONFLICTS DETECTED:&quot;)&#10;            print(generate_conflict_report(conflicts))&#10;        else:&#10;            print(&quot;✅ No conflicts detected in final schedule&quot;)&#10;        &#10;        # Quality validation&#10;        validator = ScheduleValidator(problem)&#10;        quality_report = validator.validate_and_assess(final_state)&#10;        &#10;        print(f&quot;\n{generate_quality_report(quality_report)}&quot;)&#10;        &#10;        # Preference evaluation if available&#10;        if preferences:&#10;            preference_score = preferences.evaluate_schedule_quality(final_state, problem)&#10;            print(f&quot;\n PREFERENCE SATISFACTION: {preference_score:.1%}&quot;)&#10;&#10;    # Export main JSON&#10;    export_output_json(&#10;        output_path, config=config, problem=problem,&#10;        final_state=final_state, status=&quot;success&quot;,&#10;        strategy=best_result.algorithm.lower()&#10;    )&#10;    print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;    # Auto-generate HTML&#10;    if auto_html:&#10;        _generate_html_timetable(output_path, config)&#10;&#10;    # Enhanced export formats&#10;    if export_formats:&#10;        try:&#10;            with open(output_path, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;&#10;            exporter = EnhancedTimetableExporter(data)&#10;            base_name = os.path.splitext(output_path)[0]&#10;&#10;            print(f&quot;\n EXPORTING ADDITIONAL FORMATS&quot;)&#10;            print(&quot;-&quot; * 40)&#10;&#10;            for fmt in export_formats:&#10;                if fmt == 'csv':&#10;                    exporter.export_csv(f&quot;{base_name}.csv&quot;)&#10;                elif fmt == 'ical':&#10;                    exporter.export_ical(f&quot;{base_name}.ics&quot;)&#10;                elif fmt == 'xml':&#10;                    exporter.export_xml(f&quot;{base_name}.xml&quot;)&#10;                elif fmt == 'enhanced_json':&#10;                    exporter.export_enhanced_json(f&quot;{base_name}_enhanced.json&quot;)&#10;                elif fmt == 'moodle':&#10;                    exporter.export_moodle_xml(f&quot;{base_name}_moodle.xml&quot;)&#10;                elif fmt == 'teams':&#10;                    exporter.export_teams_integration(f&quot;{base_name}_teams.json&quot;)&#10;                elif fmt == 'stats':&#10;                    exporter.export_statistics_report(f&quot;{base_name}_stats.txt&quot;)&#10;                elif fmt == 'all':&#10;                    exporter.export_all_formats(base_name)&#10;                    break&#10;&#10;        except Exception as e:&#10;            print(f&quot;⚠️ Error exporting formats: {e}&quot;)&#10;&#10;    # Create post-solve backup&#10;    if enable_backup and backup_manager:&#10;        backup_manager.create_backup(&#10;            input_path, output_path,&#10;            f&quot;Post-solve results - {best_result.algorithm} - {len(final_state)} events&quot;&#10;        )&#10;&#10;    return {&#10;        'result': best_result,&#10;        'final_state': final_state,&#10;        'conflicts': conflicts,&#10;        'quality_report': quality_report,&#10;        'preference_score': preferences.evaluate_schedule_quality(final_state, problem) if preferences else None&#10;    }&#10;&#10;&#10;def print_advanced_help():&#10;    &quot;&quot;&quot;Print help for advanced features.&quot;&quot;&quot;&#10;    help_text = &quot;&quot;&quot;&#10; ADVANCED TIMETABLING FEATURES&#10;&#10;Enhanced Solve Function:&#10;  solve_from_json_advanced(&#10;      input_path=&quot;input.json&quot;, &#10;      output_path=&quot;output.json&quot;,&#10;      compare_all=True,          # Run all algorithms&#10;      auto_html=True,            # Generate HTML automatically  &#10;      enable_validation=True,    # Quality analysis &amp; conflict detection&#10;      enable_backup=True,        # Automatic backups&#10;      export_formats=['csv', 'ical', 'stats']  # Additional export formats&#10;  )&#10;&#10;Available Export Formats:&#10;  • csv         - Spreadsheet format&#10;  • ical        - Calendar format (Outlook/Google)&#10;  • xml         - Structured XML&#10;  • enhanced_json - JSON with statistics&#10;  • moodle      - Moodle course import&#10;  • teams       - Microsoft Teams integration&#10;  • stats       - Statistics report&#10;  • all         - Export all formats&#10;&#10;Preference Configuration (in input JSON):&#10;  {&#10;    &quot;config&quot;: { ... },&#10;    &quot;preferences&quot;: {&#10;      &quot;teacher_preferences&quot;: [&#10;        {&#10;          &quot;teacher_id&quot;: &quot;T_MATH&quot;, &#10;          &quot;preferred_slots&quot;: [&quot;Mon_08-10&quot;, &quot;Tue_08-10&quot;],&#10;          &quot;weight&quot;: 0.7&#10;        }&#10;      ],&#10;      &quot;lunch_break&quot;: {&#10;        &quot;start_time&quot;: &quot;12:00&quot;,&#10;        &quot;end_time&quot;: &quot;14:00&quot;, &#10;        &quot;weight&quot;: 0.8&#10;      },&#10;      &quot;group_preferences&quot;: [&#10;        {&#10;          &quot;group_id&quot;: &quot;G1&quot;,&#10;          &quot;type&quot;: &quot;compact&quot;,&#10;          &quot;weight&quot;: 0.6&#10;        }&#10;      ],&#10;      &quot;avoid_late_classes&quot;: {&#10;        &quot;cutoff_time&quot;: &quot;18:00&quot;,&#10;        &quot;weight&quot;: 0.5&#10;      }&#10;    },&#10;    &quot;timeslots&quot;: [...],&#10;    ...&#10;  }&#10;&#10;Backup &amp; Version Control:&#10;  from timetable_backup import TimetableBackupManager, VersionControl&#10;  &#10;  # Backup management&#10;  backup = TimetableBackupManager()&#10;  backup.create_backup(&quot;input.json&quot;, &quot;output.json&quot;, &quot;Description&quot;)&#10;  backup.list_backups()&#10;  backup.restore_backup(&quot;20251231_143022&quot;)&#10;  &#10;  # Version control&#10;  vc = VersionControl()&#10;  vc.commit_version([&quot;input.json&quot;, &quot;output.json&quot;], &quot;Version message&quot;)&#10;  vc.checkout_version(&quot;20251231_143022&quot;)&#10;&#10;Manual Analysis:&#10;  from timetable_conflicts import ConflictDetector&#10;  from timetable_validation import ScheduleValidator&#10;  &#10;  # Conflict analysis&#10;  detector = ConflictDetector(problem)&#10;  conflicts = detector.analyze_schedule(assignment)&#10;  &#10;  # Quality assessment  &#10;  validator = ScheduleValidator(problem)&#10;  report = validator.validate_and_assess(assignment)&#10;&quot;&quot;&quot;&#10;    print(help_text)&#10;&#10;&#10;# Import new advanced features&#10;try:&#10;    from timetable_preferences import PreferenceManager, load_preferences_from_json&#10;    from timetable_conflicts import ConflictDetector, generate_conflict_report&#10;    from timetable_validation import ScheduleValidator, generate_quality_report&#10;    from timetable_backup import TimetableBackupManager, auto_backup_wrapper&#10;    from timetable_enhanced_export import EnhancedTimetableExporter&#10;    ADVANCED_FEATURES = True&#10;except ImportError as e:&#10;    # Create dummy classes/functions for graceful fallback&#10;    class PreferenceManager:&#10;        def __init__(self): pass&#10;    class ConflictDetector:&#10;        def __init__(self, problem): pass&#10;    class ScheduleValidator:&#10;        def __init__(self, problem): pass  &#10;    class TimetableBackupManager:&#10;        def __init__(self): pass&#10;    class EnhancedTimetableExporter:&#10;        def __init__(self, data): pass&#10;    &#10;    def load_preferences_from_json(data): return PreferenceManager()&#10;    def generate_conflict_report(conflicts): return &quot;&quot;&#10;    def generate_quality_report(report): return &quot;&quot;&#10;    def auto_backup_wrapper(func): return func&#10;    &#10;    print(f&quot;⚠️ Advanced features not available: {e}&quot;)&#10;    ADVANCED_FEATURES = False&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Enable advanced features for testing&#10;    if ADVANCED_FEATURES:&#10;        print(&quot; Running with ADVANCED FEATURES enabled&quot;)&#10;        solve_from_json_advanced(&#10;            &quot;test/09_real_world_scenario.json&quot;,&#10;            &quot;timetable_output.json&quot;,&#10;            compare_all=False,&#10;            enable_validation=True,&#10;            enable_backup=True,&#10;            export_formats=['csv', 'ical', 'stats']&#10;        )&#10;    else:&#10;        print(&quot; Running with BASIC FEATURES only&quot;)&#10;        solve_from_json(&quot;test/09_real_world_scenario.json&quot;, &quot;timetable_output.json&quot;, compare_all=False)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_backup.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_backup.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Backup and recovery system for timetables.&#10;Provides versioning, backup creation, and recovery capabilities.&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import os&#10;import shutil&#10;from datetime import datetime&#10;from typing import Dict, List, Optional, Tuple&#10;from dataclasses import dataclass, asdict&#10;&#10;@dataclass&#10;class BackupInfo:&#10;    &quot;&quot;&quot;Information about a backup file.&quot;&quot;&quot;&#10;    filename: str&#10;    timestamp: datetime&#10;    version: str&#10;    description: str&#10;    file_size: int&#10;    checksum: str&#10;&#10;class TimetableBackupManager:&#10;    &quot;&quot;&quot;Manages backup and recovery of timetable data.&quot;&quot;&quot;&#10;    &#10;    def __init__(self, backup_dir: str = &quot;backups&quot;):&#10;        self.backup_dir = backup_dir&#10;        self.ensure_backup_dir()&#10;    &#10;    def ensure_backup_dir(self):&#10;        &quot;&quot;&quot;Create backup directory if it doesn't exist.&quot;&quot;&quot;&#10;        if not os.path.exists(self.backup_dir):&#10;            os.makedirs(self.backup_dir)&#10;    &#10;    def create_backup(self, input_file: str, output_file: str, description: str = &quot;&quot;) -&gt; str:&#10;        &quot;&quot;&quot;Create a backup of input and output files.&quot;&quot;&quot;&#10;        timestamp = datetime.now()&#10;        version = timestamp.strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        &#10;        # Create backup filenames&#10;        input_backup = os.path.join(self.backup_dir, f&quot;input_{version}.json&quot;)&#10;        output_backup = os.path.join(self.backup_dir, f&quot;output_{version}.json&quot;)&#10;        metadata_file = os.path.join(self.backup_dir, f&quot;metadata_{version}.json&quot;)&#10;        &#10;        # Copy files&#10;        if os.path.exists(input_file):&#10;            shutil.copy2(input_file, input_backup)&#10;        &#10;        if os.path.exists(output_file):&#10;            shutil.copy2(output_file, output_backup)&#10;        &#10;        # Create metadata&#10;        metadata = {&#10;            &quot;version&quot;: version,&#10;            &quot;timestamp&quot;: timestamp.isoformat(),&#10;            &quot;description&quot;: description or f&quot;Backup created on {timestamp.strftime('%Y-%m-%d %H:%M:%S')}&quot;,&#10;            &quot;input_file&quot;: input_backup,&#10;            &quot;output_file&quot;: output_backup if os.path.exists(output_file) else None,&#10;            &quot;original_input&quot;: input_file,&#10;            &quot;original_output&quot;: output_file&#10;        }&#10;        &#10;        with open(metadata_file, 'w') as f:&#10;            json.dump(metadata, f, indent=2)&#10;        &#10;        print(f&quot;✅ Backup created: {version}&quot;)&#10;        print(f&quot;   Input: {input_backup}&quot;)&#10;        if os.path.exists(output_file):&#10;            print(f&quot;   Output: {output_backup}&quot;)&#10;        print(f&quot;   Metadata: {metadata_file}&quot;)&#10;        &#10;        return version&#10;    &#10;    def list_backups(self) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;List all available backups.&quot;&quot;&quot;&#10;        backups = []&#10;        &#10;        for filename in os.listdir(self.backup_dir):&#10;            if filename.startswith(&quot;metadata_&quot;) and filename.endswith(&quot;.json&quot;):&#10;                metadata_path = os.path.join(self.backup_dir, filename)&#10;                try:&#10;                    with open(metadata_path, 'r') as f:&#10;                        metadata = json.load(f)&#10;                    backups.append(metadata)&#10;                except Exception as e:&#10;                    print(f&quot;⚠️ Error reading backup metadata {filename}: {e}&quot;)&#10;        &#10;        # Sort by timestamp (newest first)&#10;        backups.sort(key=lambda x: x['timestamp'], reverse=True)&#10;        return backups&#10;    &#10;    def restore_backup(self, version: str, target_dir: str = &quot;.&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Restore a backup to target directory.&quot;&quot;&quot;&#10;        metadata_file = os.path.join(self.backup_dir, f&quot;metadata_{version}.json&quot;)&#10;        &#10;        if not os.path.exists(metadata_file):&#10;            print(f&quot;❌ Backup version {version} not found&quot;)&#10;            return False&#10;        &#10;        try:&#10;            with open(metadata_file, 'r') as f:&#10;                metadata = json.load(f)&#10;            &#10;            # Restore input file&#10;            input_backup = metadata[&quot;input_file&quot;]&#10;            if os.path.exists(input_backup):&#10;                target_input = os.path.join(target_dir, &quot;restored_input.json&quot;)&#10;                shutil.copy2(input_backup, target_input)&#10;                print(f&quot;✅ Input restored to: {target_input}&quot;)&#10;            &#10;            # Restore output file if it exists&#10;            output_backup = metadata.get(&quot;output_file&quot;)&#10;            if output_backup and os.path.exists(output_backup):&#10;                target_output = os.path.join(target_dir, &quot;restored_output.json&quot;)&#10;                shutil.copy2(output_backup, target_output)&#10;                print(f&quot;✅ Output restored to: {target_output}&quot;)&#10;            &#10;            print(f&quot;✅ Backup {version} restored successfully&quot;)&#10;            print(f&quot;   Description: {metadata.get('description', 'N/A')}&quot;)&#10;            print(f&quot;   Original timestamp: {metadata['timestamp']}&quot;)&#10;            &#10;            return True&#10;            &#10;        except Exception as e:&#10;            print(f&quot;❌ Error restoring backup {version}: {e}&quot;)&#10;            return False&#10;    &#10;    def delete_backup(self, version: str) -&gt; bool:&#10;        &quot;&quot;&quot;Delete a specific backup.&quot;&quot;&quot;&#10;        files_to_delete = [&#10;            f&quot;input_{version}.json&quot;,&#10;            f&quot;output_{version}.json&quot;, &#10;            f&quot;metadata_{version}.json&quot;&#10;        ]&#10;        &#10;        deleted_count = 0&#10;        for filename in files_to_delete:&#10;            filepath = os.path.join(self.backup_dir, filename)&#10;            if os.path.exists(filepath):&#10;                os.remove(filepath)&#10;                deleted_count += 1&#10;        &#10;        if deleted_count &gt; 0:&#10;            print(f&quot;✅ Backup {version} deleted ({deleted_count} files)&quot;)&#10;            return True&#10;        else:&#10;            print(f&quot;❌ No files found for backup {version}&quot;)&#10;            return False&#10;    &#10;    def cleanup_old_backups(self, keep_count: int = 10):&#10;        &quot;&quot;&quot;Keep only the most recent N backups.&quot;&quot;&quot;&#10;        backups = self.list_backups()&#10;        &#10;        if len(backups) &lt;= keep_count:&#10;            print(f&quot;ℹ️ Only {len(backups)} backups found, nothing to clean up&quot;)&#10;            return&#10;        &#10;        # Delete oldest backups&#10;        to_delete = backups[keep_count:]&#10;        deleted_count = 0&#10;        &#10;        for backup in to_delete:&#10;            version = backup['version']&#10;            if self.delete_backup(version):&#10;                deleted_count += 1&#10;        &#10;        print(f&quot; Cleaned up {deleted_count} old backups, kept {keep_count} most recent&quot;)&#10;    &#10;    def export_backup_summary(self, output_file: str = &quot;backup_summary.json&quot;):&#10;        &quot;&quot;&quot;Export summary of all backups.&quot;&quot;&quot;&#10;        backups = self.list_backups()&#10;        &#10;        summary = {&#10;            &quot;backup_directory&quot;: self.backup_dir,&#10;            &quot;total_backups&quot;: len(backups),&#10;            &quot;export_timestamp&quot;: datetime.now().isoformat(),&#10;            &quot;backups&quot;: backups&#10;        }&#10;        &#10;        with open(output_file, 'w') as f:&#10;            json.dump(summary, f, indent=2)&#10;        &#10;        print(f&quot; Backup summary exported to: {output_file}&quot;)&#10;&#10;def auto_backup_wrapper(func):&#10;    &quot;&quot;&quot;Decorator to automatically create backups before running timetable operations.&quot;&quot;&quot;&#10;    def wrapper(*args, **kwargs):&#10;        # Extract input/output paths from arguments&#10;        input_path = args[0] if args else None&#10;        output_path = args[1] if len(args) &gt; 1 else kwargs.get('output_path', 'timetable_output.json')&#10;        &#10;        if input_path:&#10;            backup_manager = TimetableBackupManager()&#10;            backup_manager.create_backup(&#10;                input_path, &#10;                output_path, &#10;                f&quot;Auto-backup before running {func.__name__}&quot;&#10;            )&#10;        &#10;        # Run the original function&#10;        result = func(*args, **kwargs)&#10;        &#10;        # Create backup of results if successful&#10;        if input_path and os.path.exists(output_path):&#10;            backup_manager.create_backup(&#10;                input_path,&#10;                output_path,&#10;                f&quot;Results from {func.__name__} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&quot;&#10;            )&#10;        &#10;        return result&#10;    &#10;    return wrapper&#10;&#10;class VersionControl:&#10;    &quot;&quot;&quot;Simple version control for timetable configurations.&quot;&quot;&quot;&#10;    &#10;    def __init__(self, project_dir: str = &quot;.&quot;):&#10;        self.project_dir = project_dir&#10;        self.versions_dir = os.path.join(project_dir, &quot;versions&quot;)&#10;        self.ensure_versions_dir()&#10;    &#10;    def ensure_versions_dir(self):&#10;        &quot;&quot;&quot;Create versions directory if it doesn't exist.&quot;&quot;&quot;&#10;        if not os.path.exists(self.versions_dir):&#10;            os.makedirs(self.versions_dir)&#10;    &#10;    def commit_version(self, files: List[str], message: str) -&gt; str:&#10;        &quot;&quot;&quot;Commit a new version of timetable files.&quot;&quot;&quot;&#10;        timestamp = datetime.now()&#10;        version_id = timestamp.strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        version_dir = os.path.join(self.versions_dir, version_id)&#10;        &#10;        os.makedirs(version_dir)&#10;        &#10;        # Copy files to version directory&#10;        copied_files = []&#10;        for file_path in files:&#10;            if os.path.exists(file_path):&#10;                filename = os.path.basename(file_path)&#10;                target_path = os.path.join(version_dir, filename)&#10;                shutil.copy2(file_path, target_path)&#10;                copied_files.append(filename)&#10;        &#10;        # Create version metadata&#10;        metadata = {&#10;            &quot;version_id&quot;: version_id,&#10;            &quot;timestamp&quot;: timestamp.isoformat(),&#10;            &quot;message&quot;: message,&#10;            &quot;files&quot;: copied_files,&#10;            &quot;commit_author&quot;: os.getenv('USERNAME', 'unknown')&#10;        }&#10;        &#10;        metadata_file = os.path.join(version_dir, &quot;version.json&quot;)&#10;        with open(metadata_file, 'w') as f:&#10;            json.dump(metadata, f, indent=2)&#10;        &#10;        print(f&quot;✅ Version {version_id} committed&quot;)&#10;        print(f&quot;   Message: {message}&quot;)&#10;        print(f&quot;   Files: {', '.join(copied_files)}&quot;)&#10;        &#10;        return version_id&#10;    &#10;    def list_versions(self) -&gt; List[Dict]:&#10;        &quot;&quot;&quot;List all committed versions.&quot;&quot;&quot;&#10;        versions = []&#10;        &#10;        for version_dir in os.listdir(self.versions_dir):&#10;            version_path = os.path.join(self.versions_dir, version_dir)&#10;            if os.path.isdir(version_path):&#10;                metadata_file = os.path.join(version_path, &quot;version.json&quot;)&#10;                if os.path.exists(metadata_file):&#10;                    with open(metadata_file, 'r') as f:&#10;                        metadata = json.load(f)&#10;                    versions.append(metadata)&#10;        &#10;        versions.sort(key=lambda x: x['timestamp'], reverse=True)&#10;        return versions&#10;    &#10;    def checkout_version(self, version_id: str, target_dir: str = &quot;.&quot;) -&gt; bool:&#10;        &quot;&quot;&quot;Checkout a specific version.&quot;&quot;&quot;&#10;        version_dir = os.path.join(self.versions_dir, version_id)&#10;        &#10;        if not os.path.exists(version_dir):&#10;            print(f&quot;❌ Version {version_id} not found&quot;)&#10;            return False&#10;        &#10;        metadata_file = os.path.join(version_dir, &quot;version.json&quot;)&#10;        if not os.path.exists(metadata_file):&#10;            print(f&quot;❌ Version metadata not found for {version_id}&quot;)&#10;            return False&#10;        &#10;        with open(metadata_file, 'r') as f:&#10;            metadata = json.load(f)&#10;        &#10;        # Copy files from version directory&#10;        for filename in metadata['files']:&#10;            source_path = os.path.join(version_dir, filename)&#10;            target_path = os.path.join(target_dir, filename)&#10;            &#10;            if os.path.exists(source_path):&#10;                shutil.copy2(source_path, target_path)&#10;                print(f&quot;✅ Restored: {filename}&quot;)&#10;        &#10;        print(f&quot;✅ Checked out version {version_id}&quot;)&#10;        print(f&quot;   Message: {metadata['message']}&quot;)&#10;        print(f&quot;   Date: {metadata['timestamp']}&quot;)&#10;        &#10;        return True&#10;&#10;def print_backup_help():&#10;    &quot;&quot;&quot;Print help information for backup system.&quot;&quot;&quot;&#10;    help_text = &quot;&quot;&quot;&#10; BACKUP SYSTEM USAGE&#10;&#10;Basic Commands:&#10;  backup_manager = TimetableBackupManager()&#10;  &#10;  # Create backup&#10;  backup_manager.create_backup(&quot;input.json&quot;, &quot;output.json&quot;, &quot;My backup&quot;)&#10;  &#10;  # List backups&#10;  backups = backup_manager.list_backups()&#10;  &#10;  # Restore backup&#10;  backup_manager.restore_backup(&quot;20251231_143022&quot;)&#10;  &#10;  # Clean up old backups&#10;  backup_manager.cleanup_old_backups(keep_count=5)&#10;&#10;Version Control:&#10;  vc = VersionControl()&#10;  &#10;  # Commit version&#10;  vc.commit_version([&quot;input.json&quot;, &quot;output.json&quot;], &quot;Initial timetable&quot;)&#10;  &#10;  # List versions&#10;  versions = vc.list_versions()&#10;  &#10;  # Checkout version&#10;  vc.checkout_version(&quot;20251231_143022&quot;)&#10;&#10;Auto-backup Decorator:&#10;  @auto_backup_wrapper&#10;  def solve_from_json(input_path, output_path):&#10;      # Function automatically backed up&#10;      pass&#10;&quot;&quot;&quot;&#10;    print(help_text)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    print_backup_help()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_conflicts.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_conflicts.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Advanced conflict detection and resolution system for timetabling.&#10;Provides detailed conflict analysis and suggestions for resolution.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;from dataclasses import dataclass&#10;from typing import List, Dict, Set, Tuple, Optional&#10;from enum import Enum&#10;&#10;class ConflictType(Enum):&#10;    &quot;&quot;&quot;Types of scheduling conflicts.&quot;&quot;&quot;&#10;    TEACHER_DOUBLE_BOOKING = &quot;teacher_double_booking&quot;&#10;    ROOM_DOUBLE_BOOKING = &quot;room_double_booking&quot;&#10;    GROUP_DOUBLE_BOOKING = &quot;group_double_booking&quot;&#10;    CAPACITY_EXCEEDED = &quot;capacity_exceeded&quot;&#10;    TEACHER_UNAVAILABLE = &quot;teacher_unavailable&quot;&#10;    ROOM_UNAVAILABLE = &quot;room_unavailable&quot;&#10;    GROUP_UNAVAILABLE = &quot;group_unavailable&quot;&#10;    DURATION_MISMATCH = &quot;duration_mismatch&quot;&#10;    INSUFFICIENT_WEEKLY_HOURS = &quot;insufficient_weekly_hours&quot;&#10;    EXCESSIVE_DAILY_LOAD = &quot;excessive_daily_load&quot;&#10;&#10;@dataclass&#10;class Conflict:&#10;    &quot;&quot;&quot;Represents a scheduling conflict with detailed information.&quot;&quot;&quot;&#10;    type: ConflictType&#10;    severity: str  # &quot;critical&quot;, &quot;warning&quot;, &quot;minor&quot;&#10;    description: str&#10;    affected_entities: List[str]  # IDs of affected teachers, rooms, groups, events&#10;    timeslot: Optional[str] = None&#10;    suggestions: List[str] = None&#10;    &#10;    def __post_init__(self):&#10;        if self.suggestions is None:&#10;            self.suggestions = []&#10;&#10;class ConflictDetector:&#10;    &quot;&quot;&quot;Detects and analyzes scheduling conflicts.&quot;&quot;&quot;&#10;    &#10;    def __init__(self, problem):&#10;        self.problem = problem&#10;        self.conflicts: List[Conflict] = []&#10;    &#10;    def analyze_schedule(self, assignment) -&gt; List[Conflict]:&#10;        &quot;&quot;&quot;Comprehensive conflict analysis of a schedule.&quot;&quot;&quot;&#10;        self.conflicts = []&#10;        &#10;        # Check hard constraint violations&#10;        self._check_double_bookings(assignment)&#10;        self._check_capacity_violations(assignment)&#10;        self._check_availability_violations(assignment)&#10;        self._check_duration_mismatches(assignment)&#10;        &#10;        # Check soft constraint violations&#10;        self._check_weekly_hour_requirements(assignment)&#10;        self._check_daily_load_distribution(assignment)&#10;        &#10;        return self.conflicts&#10;    &#10;    def _check_double_bookings(self, assignment):&#10;        &quot;&quot;&quot;Check for teacher, room, and group double bookings.&quot;&quot;&quot;&#10;        # Group by timeslot for conflict detection&#10;        timeslot_assignments = {}&#10;        for eid, tid, rid in assignment:&#10;            if tid not in timeslot_assignments:&#10;                timeslot_assignments[tid] = []&#10;            timeslot_assignments[tid].append((eid, rid))&#10;        &#10;        for tid, assignments in timeslot_assignments.items():&#10;            if len(assignments) &lt;= 1:&#10;                continue&#10;                &#10;            # Check teacher conflicts&#10;            teachers_in_slot = {}&#10;            rooms_in_slot = {}&#10;            groups_in_slot = {}&#10;            &#10;            for eid, rid in assignments:&#10;                event = self.problem.events[eid]&#10;                teacher_id = event.teacher_id&#10;                &#10;                # Teacher conflicts&#10;                if teacher_id in teachers_in_slot:&#10;                    # Check if weeks overlap&#10;                    existing_event = self.problem.events[teachers_in_slot[teacher_id]]&#10;                    if self._weeks_overlap(event.weeks, existing_event.weeks):&#10;                        self._add_conflict(Conflict(&#10;                            type=ConflictType.TEACHER_DOUBLE_BOOKING,&#10;                            severity=&quot;critical&quot;,&#10;                            description=f&quot;Teacher {teacher_id} has overlapping assignments&quot;,&#10;                            affected_entities=[teacher_id, eid, teachers_in_slot[teacher_id]],&#10;                            timeslot=tid,&#10;                            suggestions=[&#10;                                f&quot;Move one event to a different timeslot&quot;,&#10;                                f&quot;Assign different teacher to one event&quot;,&#10;                                f&quot;Check if events can run in different weeks&quot;&#10;                            ]&#10;                        ))&#10;                else:&#10;                    teachers_in_slot[teacher_id] = eid&#10;                &#10;                # Room conflicts&#10;                if rid in rooms_in_slot:&#10;                    existing_event = self.problem.events[rooms_in_slot[rid]]&#10;                    if self._weeks_overlap(event.weeks, existing_event.weeks):&#10;                        self._add_conflict(Conflict(&#10;                            type=ConflictType.ROOM_DOUBLE_BOOKING,&#10;                            severity=&quot;critical&quot;,&#10;                            description=f&quot;Room {rid} has overlapping bookings&quot;,&#10;                            affected_entities=[rid, eid, rooms_in_slot[rid]],&#10;                            timeslot=tid,&#10;                            suggestions=[&#10;                                f&quot;Move one event to different room&quot;,&#10;                                f&quot;Move one event to different timeslot&quot;,&#10;                                f&quot;Check if events can run in different weeks&quot;&#10;                            ]&#10;                        ))&#10;                else:&#10;                    rooms_in_slot[rid] = eid&#10;                &#10;                # Group conflicts&#10;                for group_id in event.group_ids:&#10;                    if group_id in groups_in_slot:&#10;                        existing_event = self.problem.events[groups_in_slot[group_id]]&#10;                        if self._weeks_overlap(event.weeks, existing_event.weeks):&#10;                            self._add_conflict(Conflict(&#10;                                type=ConflictType.GROUP_DOUBLE_BOOKING,&#10;                                severity=&quot;critical&quot;,&#10;                                description=f&quot;Group {group_id} has overlapping classes&quot;,&#10;                                affected_entities=[group_id, eid, groups_in_slot[group_id]],&#10;                                timeslot=tid,&#10;                                suggestions=[&#10;                                    f&quot;Move one event to different timeslot&quot;,&#10;                                    f&quot;Split group into smaller groups&quot;,&#10;                                    f&quot;Check if events can run in different weeks&quot;&#10;                                ]&#10;                            ))&#10;                    else:&#10;                        groups_in_slot[group_id] = eid&#10;    &#10;    def _check_capacity_violations(self, assignment):&#10;        &quot;&quot;&quot;Check for room capacity violations.&quot;&quot;&quot;&#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            room = self.problem.rooms[rid]&#10;            &#10;            # Calculate required capacity&#10;            total_students = sum(&#10;                self.problem.groups[gid].size &#10;                for gid in event.group_ids&#10;            )&#10;            required_capacity = max(total_students, event.min_room_capacity)&#10;            &#10;            if required_capacity &gt; room.capacity:&#10;                self._add_conflict(Conflict(&#10;                    type=ConflictType.CAPACITY_EXCEEDED,&#10;                    severity=&quot;critical&quot;,&#10;                    description=f&quot;Room {rid} capacity ({room.capacity}) insufficient for event {eid} (needs {required_capacity})&quot;,&#10;                    affected_entities=[rid, eid],&#10;                    timeslot=tid,&#10;                    suggestions=[&#10;                        f&quot;Use larger room (capacity &gt;= {required_capacity})&quot;,&#10;                        f&quot;Split groups into smaller sessions&quot;,&#10;                        f&quot;Reduce group sizes&quot;&#10;                    ]&#10;                ))&#10;    &#10;    def _check_availability_violations(self, assignment):&#10;        &quot;&quot;&quot;Check for availability constraint violations.&quot;&quot;&quot;&#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            room = self.problem.rooms[rid]&#10;            teacher = self.problem.teachers[event.teacher_id]&#10;            &#10;            # Check teacher availability&#10;            if tid not in teacher.available:&#10;                self._add_conflict(Conflict(&#10;                    type=ConflictType.TEACHER_UNAVAILABLE,&#10;                    severity=&quot;critical&quot;,&#10;                    description=f&quot;Teacher {event.teacher_id} not available at {tid}&quot;,&#10;                    affected_entities=[event.teacher_id, eid],&#10;                    timeslot=tid,&#10;                    suggestions=[&#10;                        f&quot;Move event to teacher's available time&quot;,&#10;                        f&quot;Update teacher availability&quot;,&#10;                        f&quot;Assign different teacher&quot;&#10;                    ]&#10;                ))&#10;            &#10;            # Check room availability&#10;            if tid not in room.available:&#10;                self._add_conflict(Conflict(&#10;                    type=ConflictType.ROOM_UNAVAILABLE,&#10;                    severity=&quot;critical&quot;,&#10;                    description=f&quot;Room {rid} not available at {tid}&quot;,&#10;                    affected_entities=[rid, eid],&#10;                    timeslot=tid,&#10;                    suggestions=[&#10;                        f&quot;Move event to different room&quot;,&#10;                        f&quot;Move event to different timeslot&quot;,&#10;                        f&quot;Update room availability&quot;&#10;                    ]&#10;                ))&#10;            &#10;            # Check group availability&#10;            for group_id in event.group_ids:&#10;                group = self.problem.groups[group_id]&#10;                if tid not in group.available:&#10;                    self._add_conflict(Conflict(&#10;                        type=ConflictType.GROUP_UNAVAILABLE,&#10;                        severity=&quot;critical&quot;,&#10;                        description=f&quot;Group {group_id} not available at {tid}&quot;,&#10;                        affected_entities=[group_id, eid],&#10;                        timeslot=tid,&#10;                        suggestions=[&#10;                            f&quot;Move event to group's available time&quot;,&#10;                            f&quot;Update group availability&quot;,&#10;                            f&quot;Exclude group from this event&quot;&#10;                        ]&#10;                    ))&#10;            &#10;            # Check duration match&#10;            if event.duration_min != timeslot.duration_min:&#10;                self._add_conflict(Conflict(&#10;                    type=ConflictType.DURATION_MISMATCH,&#10;                    severity=&quot;critical&quot;,&#10;                    description=f&quot;Event {eid} duration ({event.duration_min}min) doesn't match timeslot {tid} ({timeslot.duration_min}min)&quot;,&#10;                    affected_entities=[eid, tid],&#10;                    timeslot=tid,&#10;                    suggestions=[&#10;                        f&quot;Use timeslot with {event.duration_min}min duration&quot;,&#10;                        f&quot;Adjust event duration to {timeslot.duration_min}min&quot;,&#10;                        f&quot;Create new timeslot with correct duration&quot;&#10;                    ]&#10;                ))&#10;    &#10;    def _check_weekly_hour_requirements(self, assignment):&#10;        &quot;&quot;&quot;Check if modules meet their weekly hour requirements.&quot;&quot;&quot;&#10;        module_hours = {}&#10;        &#10;        # Calculate actual hours per module&#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            module_id = event.module_id&#10;            &#10;            if module_id not in module_hours:&#10;                module_hours[module_id] = 0&#10;            &#10;            # Add event duration in hours&#10;            module_hours[module_id] += event.duration_min / 60.0&#10;        &#10;        # Check against expected hours&#10;        for event in self.problem.events_list:&#10;            module_id = event.module_id&#10;            expected_hours = event.module_hours_per_week&#10;            &#10;            if expected_hours &gt; 0:&#10;                actual_hours = module_hours.get(module_id, 0)&#10;                if actual_hours &lt; expected_hours:&#10;                    self._add_conflict(Conflict(&#10;                        type=ConflictType.INSUFFICIENT_WEEKLY_HOURS,&#10;                        severity=&quot;warning&quot;,&#10;                        description=f&quot;Module {module_id} has {actual_hours}h/week, expected {expected_hours}h/week&quot;,&#10;                        affected_entities=[module_id],&#10;                        suggestions=[&#10;                            f&quot;Add more events for {module_id}&quot;,&#10;                            f&quot;Increase duration of existing events&quot;,&#10;                            f&quot;Verify expected hours are correct&quot;&#10;                        ]&#10;                    ))&#10;    &#10;    def _check_daily_load_distribution(self, assignment):&#10;        &quot;&quot;&quot;Check for excessive daily loads on groups/teachers.&quot;&quot;&quot;&#10;        # Group assignments by day and entity&#10;        daily_loads = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            day = timeslot.day&#10;            &#10;            # Track teacher daily load&#10;            teacher_key = f&quot;teacher_{event.teacher_id}_{day}&quot;&#10;            if teacher_key not in daily_loads:&#10;                daily_loads[teacher_key] = 0&#10;            daily_loads[teacher_key] += event.duration_min / 60.0&#10;            &#10;            # Track group daily loads&#10;            for group_id in event.group_ids:&#10;                group_key = f&quot;group_{group_id}_{day}&quot;&#10;                if group_key not in daily_loads:&#10;                    daily_loads[group_key] = 0&#10;                daily_loads[group_key] += event.duration_min / 60.0&#10;        &#10;        # Check for excessive loads (&gt; 8 hours per day)&#10;        for key, hours in daily_loads.items():&#10;            if hours &gt; 8:&#10;                entity_type, entity_id, day = key.split('_', 2)&#10;                self._add_conflict(Conflict(&#10;                    type=ConflictType.EXCESSIVE_DAILY_LOAD,&#10;                    severity=&quot;warning&quot;,&#10;                    description=f&quot;{entity_type.title()} {entity_id} has {hours:.1f} hours on {day}&quot;,&#10;                    affected_entities=[entity_id],&#10;                    suggestions=[&#10;                        f&quot;Redistribute events across multiple days&quot;,&#10;                        f&quot;Reduce event durations&quot;,&#10;                        f&quot;Split large events into smaller sessions&quot;&#10;                    ]&#10;                ))&#10;    &#10;    def _weeks_overlap(self, weeks1, weeks2) -&gt; bool:&#10;        &quot;&quot;&quot;Check if two sets of weeks overlap.&quot;&quot;&quot;&#10;        return not weeks1.isdisjoint(weeks2)&#10;    &#10;    def _add_conflict(self, conflict: Conflict):&#10;        &quot;&quot;&quot;Add a conflict to the list.&quot;&quot;&quot;&#10;        self.conflicts.append(conflict)&#10;    &#10;    def get_conflict_summary(self) -&gt; Dict[str, int]:&#10;        &quot;&quot;&quot;Get summary of conflicts by type and severity.&quot;&quot;&quot;&#10;        summary = {&#10;            &quot;critical&quot;: 0,&#10;            &quot;warning&quot;: 0,&#10;            &quot;minor&quot;: 0,&#10;            &quot;total&quot;: len(self.conflicts)&#10;        }&#10;        &#10;        for conflict in self.conflicts:&#10;            summary[conflict.severity] += 1&#10;        &#10;        return summary&#10;    &#10;    def get_conflicts_by_entity(self, entity_id: str) -&gt; List[Conflict]:&#10;        &quot;&quot;&quot;Get all conflicts affecting a specific entity.&quot;&quot;&quot;&#10;        return [&#10;            conflict for conflict in self.conflicts&#10;            if entity_id in conflict.affected_entities&#10;        ]&#10;&#10;def generate_conflict_report(conflicts: List[Conflict]) -&gt; str:&#10;    &quot;&quot;&quot;Generate a human-readable conflict report.&quot;&quot;&quot;&#10;    if not conflicts:&#10;        return &quot;✅ No conflicts detected in the schedule.&quot;&#10;    &#10;    report = []&#10;    report.append(f&quot; CONFLICT ANALYSIS REPORT&quot;)&#10;    report.append(f&quot;=&quot; * 50)&#10;    &#10;    # Group by severity&#10;    by_severity = {}&#10;    for conflict in conflicts:&#10;        if conflict.severity not in by_severity:&#10;            by_severity[conflict.severity] = []&#10;        by_severity[conflict.severity].append(conflict)&#10;    &#10;    for severity in [&quot;critical&quot;, &quot;warning&quot;, &quot;minor&quot;]:&#10;        if severity not in by_severity:&#10;            continue&#10;            &#10;        severity_conflicts = by_severity[severity]&#10;        icon = &quot;&quot; if severity == &quot;critical&quot; else &quot;&quot; if severity == &quot;warning&quot; else &quot;&quot;&#10;        &#10;        report.append(f&quot;\n{icon} {severity.upper()} CONFLICTS ({len(severity_conflicts)})&quot;)&#10;        report.append(&quot;-&quot; * 30)&#10;        &#10;        for i, conflict in enumerate(severity_conflicts, 1):&#10;            report.append(f&quot;\n{i}. {conflict.description}&quot;)&#10;            report.append(f&quot;   Type: {conflict.type.value}&quot;)&#10;            report.append(f&quot;   Affected: {', '.join(conflict.affected_entities)}&quot;)&#10;            if conflict.timeslot:&#10;                report.append(f&quot;   Timeslot: {conflict.timeslot}&quot;)&#10;            &#10;            if conflict.suggestions:&#10;                report.append(f&quot;    Suggestions:&quot;)&#10;                for suggestion in conflict.suggestions:&#10;                    report.append(f&quot;      • {suggestion}&quot;)&#10;    &#10;    report.append(f&quot;\n SUMMARY&quot;)&#10;    report.append(f&quot;Total conflicts: {len(conflicts)}&quot;)&#10;    report.append(f&quot;Critical: {len(by_severity.get('critical', []))}&quot;)&#10;    report.append(f&quot;Warning: {len(by_severity.get('warning', []))}&quot;)&#10;    report.append(f&quot;Minor: {len(by_severity.get('minor', []))}&quot;)&#10;    &#10;    return &quot;\n&quot;.join(report)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_enhanced_export.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_enhanced_export.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Enhanced export capabilities for timetables.&#10;Supports multiple formats, customizable layouts, and integration with external systems.&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import csv&#10;from datetime import datetime, timedelta&#10;from typing import Dict, List, Optional, Any&#10;import xml.etree.ElementTree as ET&#10;from dataclasses import dataclass&#10;&#10;@dataclass&#10;class ExportFormat:&#10;    &quot;&quot;&quot;Configuration for export format.&quot;&quot;&quot;&#10;    name: str&#10;    extension: str&#10;    description: str&#10;    supports_filtering: bool = True&#10;    supports_styling: bool = False&#10;&#10;class EnhancedTimetableExporter:&#10;    &quot;&quot;&quot;Enhanced exporter with multiple format support.&quot;&quot;&quot;&#10;    &#10;    FORMATS = {&#10;        'csv': ExportFormat('CSV', 'csv', 'Comma-separated values for spreadsheets', True, False),&#10;        'excel': ExportFormat('Excel', 'xlsx', 'Microsoft Excel format', True, True),&#10;        'ical': ExportFormat('iCal', 'ics', 'Calendar format for Outlook/Google Calendar', True, False),&#10;        'xml': ExportFormat('XML', 'xml', 'Structured XML format', True, False),&#10;        'json': ExportFormat('JSON', 'json', 'Enhanced JSON with metadata', True, False),&#10;        'pdf': ExportFormat('PDF', 'pdf', 'Formatted PDF document', True, True),&#10;        'moodle': ExportFormat('Moodle', 'xml', 'Moodle course import format', False, False),&#10;        'teams': ExportFormat('Teams', 'json', 'Microsoft Teams integration', False, False)&#10;    }&#10;    &#10;    def __init__(self, timetable_data: Dict):&#10;        self.data = timetable_data&#10;        self.assignments = timetable_data.get('assignments', [])&#10;        self.meta = timetable_data.get('meta', {})&#10;    &#10;    def export_csv(self, output_file: str, include_details: bool = True):&#10;        &quot;&quot;&quot;Export to CSV format.&quot;&quot;&quot;&#10;        with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:&#10;            fieldnames = [&#10;                'Event', 'Module', 'Teacher', 'Groups', 'Day', 'Start Time', 'End Time',&#10;                'Room', 'Duration (hours)', 'Weeks', 'Students', 'Room Capacity'&#10;            ]&#10;            &#10;            if include_details:&#10;                fieldnames.extend(['Session', 'Module Hours/Week', 'Required Capacity'])&#10;            &#10;            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)&#10;            writer.writeheader()&#10;            &#10;            for assignment in self.assignments:&#10;                # Parse timeslot&#10;                timeslot_parts = assignment['timeslot_id'].split('_')&#10;                day = timeslot_parts[0] if len(timeslot_parts) &gt; 0 else 'Unknown'&#10;                time_range = timeslot_parts[1] if len(timeslot_parts) &gt; 1 else 'Unknown'&#10;                &#10;                start_time, end_time = 'Unknown', 'Unknown'&#10;                if '-' in time_range:&#10;                    times = time_range.split('-')&#10;                    start_time = times[0].replace('-', ':')&#10;                    end_time = times[1].replace('-', ':') if len(times) &gt; 1 else 'Unknown'&#10;                &#10;                row = {&#10;                    'Event': assignment['event_id'],&#10;                    'Module': assignment['module_id'],&#10;                    'Teacher': assignment['teacher_id'],&#10;                    'Groups': ', '.join(assignment['group_ids']),&#10;                    'Day': day,&#10;                    'Start Time': start_time,&#10;                    'End Time': end_time,&#10;                    'Room': assignment['room_id'],&#10;                    'Duration (hours)': assignment.get('duration_hours', 0),&#10;                    'Weeks': ', '.join(map(str, assignment['weeks'])),&#10;                    'Students': assignment['demand'],&#10;                    'Room Capacity': assignment['room_capacity']&#10;                }&#10;                &#10;                if include_details:&#10;                    row.update({&#10;                        'Session': assignment['session_id'],&#10;                        'Module Hours/Week': assignment.get('module_hours_per_week', 0),&#10;                        'Required Capacity': assignment['required_capacity']&#10;                    })&#10;                &#10;                writer.writerow(row)&#10;        &#10;        print(f&quot;✅ CSV exported to: {output_file}&quot;)&#10;    &#10;    def export_ical(self, output_file: str):&#10;        &quot;&quot;&quot;Export to iCal format for calendar applications.&quot;&quot;&quot;&#10;        lines = [&#10;            'BEGIN:VCALENDAR',&#10;            'VERSION:2.0',&#10;            'PRODID:-//Timetable Agent//Timetable Generator//EN',&#10;            'CALSCALE:GREGORIAN'&#10;        ]&#10;        &#10;        # Calculate dates (assuming current academic year)&#10;        base_date = datetime.now().replace(month=9, day=1)  # September 1st&#10;        if datetime.now().month &lt; 9:&#10;            base_date = base_date.replace(year=base_date.year - 1)&#10;        &#10;        for assignment in self.assignments:&#10;            # Parse timeslot&#10;            timeslot_parts = assignment['timeslot_id'].split('_')&#10;            day = timeslot_parts[0] if len(timeslot_parts) &gt; 0 else 'Mon'&#10;            time_range = timeslot_parts[1] if len(timeslot_parts) &gt; 1 else '08-10'&#10;            &#10;            # Convert to datetime&#10;            day_offset = {'Mon': 0, 'Tue': 1, 'Wed': 2, 'Thu': 3, 'Fri': 4, 'Sat': 5, 'Sun': 6}.get(day, 0)&#10;            start_date = base_date + timedelta(days=day_offset)&#10;            &#10;            # Parse time&#10;            if '-' in time_range:&#10;                start_time_str, end_time_str = time_range.split('-')&#10;                start_hour = int(start_time_str[:2])&#10;                start_minute = int(start_time_str[2:]) if len(start_time_str) &gt; 2 else 0&#10;                end_hour = int(end_time_str[:2])&#10;                end_minute = int(end_time_str[2:]) if len(end_time_str) &gt; 2 else 0&#10;                &#10;                start_datetime = start_date.replace(hour=start_hour, minute=start_minute)&#10;                end_datetime = start_date.replace(hour=end_hour, minute=end_minute)&#10;                &#10;                # Create event for each week&#10;                for week in assignment['weeks'][:5]:  # Limit to first 5 weeks for demo&#10;                    event_start = start_datetime + timedelta(weeks=week-1)&#10;                    event_end = end_datetime + timedelta(weeks=week-1)&#10;                    &#10;                    lines.extend([&#10;                        'BEGIN:VEVENT',&#10;                        f'UID:{assignment[&quot;event_id&quot;]}-week{week}@timetable-agent',&#10;                        f'DTSTART:{event_start.strftime(&quot;%Y%m%dT%H%M%S&quot;)}',&#10;                        f'DTEND:{event_end.strftime(&quot;%Y%m%dT%H%M%S&quot;)}',&#10;                        f'SUMMARY:{assignment[&quot;event_id&quot;]} - {assignment[&quot;module_id&quot;]}',&#10;                        f'DESCRIPTION:Teacher: {assignment[&quot;teacher_id&quot;]}\\nGroups: {&quot;, &quot;.join(assignment[&quot;group_ids&quot;])}\\nStudents: {assignment[&quot;demand&quot;]}',&#10;                        f'LOCATION:{assignment[&quot;room_id&quot;]}',&#10;                        'END:VEVENT'&#10;                    ])&#10;        &#10;        lines.append('END:VCALENDAR')&#10;        &#10;        with open(output_file, 'w', encoding='utf-8') as f:&#10;            f.write('\\n'.join(lines))&#10;        &#10;        print(f&quot; iCal exported to: {output_file}&quot;)&#10;    &#10;    def export_xml(self, output_file: str):&#10;        &quot;&quot;&quot;Export to XML format.&quot;&quot;&quot;&#10;        root = ET.Element('timetable')&#10;        &#10;        # Metadata&#10;        meta_elem = ET.SubElement(root, 'metadata')&#10;        for key, value in self.meta.items():&#10;            elem = ET.SubElement(meta_elem, key)&#10;            elem.text = str(value)&#10;        &#10;        # Assignments&#10;        assignments_elem = ET.SubElement(root, 'assignments')&#10;        &#10;        for assignment in self.assignments:&#10;            assign_elem = ET.SubElement(assignments_elem, 'assignment')&#10;            &#10;            for key, value in assignment.items():&#10;                if isinstance(value, list):&#10;                    list_elem = ET.SubElement(assign_elem, key)&#10;                    for item in value:&#10;                        item_elem = ET.SubElement(list_elem, 'item')&#10;                        item_elem.text = str(item)&#10;                else:&#10;                    elem = ET.SubElement(assign_elem, key)&#10;                    elem.text = str(value)&#10;        &#10;        # Write to file&#10;        tree = ET.ElementTree(root)&#10;        ET.indent(tree, space=&quot;  &quot;, level=0)&#10;        tree.write(output_file, encoding='utf-8', xml_declaration=True)&#10;        &#10;        print(f&quot; XML exported to: {output_file}&quot;)&#10;    &#10;    def export_enhanced_json(self, output_file: str):&#10;        &quot;&quot;&quot;Export enhanced JSON with additional metadata and statistics.&quot;&quot;&quot;&#10;        enhanced_data = self.data.copy()&#10;        &#10;        # Add statistics&#10;        stats = self._calculate_statistics()&#10;        enhanced_data['statistics'] = stats&#10;        &#10;        # Add export metadata&#10;        enhanced_data['export_info'] = {&#10;            'export_timestamp': datetime.now().isoformat(),&#10;            'export_version': '2.0',&#10;            'total_assignments': len(self.assignments),&#10;            'unique_teachers': len(set(a['teacher_id'] for a in self.assignments)),&#10;            'unique_rooms': len(set(a['room_id'] for a in self.assignments)),&#10;            'unique_modules': len(set(a['module_id'] for a in self.assignments))&#10;        }&#10;        &#10;        with open(output_file, 'w', encoding='utf-8') as f:&#10;            json.dump(enhanced_data, f, indent=2, ensure_ascii=False)&#10;        &#10;        print(f&quot;✨ Enhanced JSON exported to: {output_file}&quot;)&#10;    &#10;    def export_moodle_xml(self, output_file: str):&#10;        &quot;&quot;&quot;Export in Moodle course format.&quot;&quot;&quot;&#10;        root = ET.Element('moodle_backup')&#10;        &#10;        # Course information&#10;        course = ET.SubElement(root, 'course')&#10;        ET.SubElement(course, 'fullname').text = f&quot;Timetable - {self.meta.get('week_name', 'Schedule')}&quot;&#10;        ET.SubElement(course, 'shortname').text = f&quot;TT_{self.meta.get('week_name', 'SCH')}&quot;&#10;        ET.SubElement(course, 'category').text = &quot;Timetables&quot;&#10;        &#10;        # Activities (events as activities)&#10;        activities = ET.SubElement(root, 'activities')&#10;        &#10;        for i, assignment in enumerate(self.assignments):&#10;            activity = ET.SubElement(activities, 'activity')&#10;            activity.set('id', str(i + 1))&#10;            &#10;            ET.SubElement(activity, 'modulename').text = 'label'&#10;            ET.SubElement(activity, 'name').text = assignment['event_id']&#10;            ET.SubElement(activity, 'intro').text = f&quot;&quot;&quot;&#10;            &lt;p&gt;&lt;strong&gt;Module:&lt;/strong&gt; {assignment['module_id']}&lt;/p&gt;&#10;            &lt;p&gt;&lt;strong&gt;Teacher:&lt;/strong&gt; {assignment['teacher_id']}&lt;/p&gt;&#10;            &lt;p&gt;&lt;strong&gt;Room:&lt;/strong&gt; {assignment['room_id']}&lt;/p&gt;&#10;            &lt;p&gt;&lt;strong&gt;Groups:&lt;/strong&gt; {', '.join(assignment['group_ids'])}&lt;/p&gt;&#10;            &lt;p&gt;&lt;strong&gt;Schedule:&lt;/strong&gt; {assignment['timeslot_id']}&lt;/p&gt;&#10;            &lt;p&gt;&lt;strong&gt;Weeks:&lt;/strong&gt; {', '.join(map(str, assignment['weeks']))}&lt;/p&gt;&#10;            &quot;&quot;&quot;&#10;        &#10;        tree = ET.ElementTree(root)&#10;        ET.indent(tree, space=&quot;  &quot;, level=0)&#10;        tree.write(output_file, encoding='utf-8', xml_declaration=True)&#10;        &#10;        print(f&quot; Moodle XML exported to: {output_file}&quot;)&#10;    &#10;    def export_teams_integration(self, output_file: str):&#10;        &quot;&quot;&quot;Export for Microsoft Teams integration.&quot;&quot;&quot;&#10;        teams_data = {&#10;            'version': '1.0',&#10;            'name': f&quot;Timetable - {self.meta.get('week_name', 'Schedule')}&quot;,&#10;            'description': f&quot;Generated timetable with {len(self.assignments)} events&quot;,&#10;            'created': datetime.now().isoformat(),&#10;            'meetings': []&#10;        }&#10;        &#10;        for assignment in self.assignments:&#10;            # Parse timeslot for Teams meeting&#10;            timeslot_parts = assignment['timeslot_id'].split('_')&#10;            day = timeslot_parts[0] if len(timeslot_parts) &gt; 0 else 'Mon'&#10;            &#10;            meeting = {&#10;                'id': assignment['event_id'],&#10;                'subject': f&quot;{assignment['module_id']} - {assignment['event_id']}&quot;,&#10;                'organizer': assignment['teacher_id'],&#10;                'attendees': assignment['group_ids'],&#10;                'location': assignment['room_id'],&#10;                'recurrence': {&#10;                    'pattern': 'weekly',&#10;                    'dayOfWeek': day.lower(),&#10;                    'weeks': assignment['weeks']&#10;                },&#10;                'duration_minutes': assignment['duration_min'],&#10;                'description': f&quot;Module: {assignment['module_id']}\\nTeacher: {assignment['teacher_id']}\\nStudents: {assignment['demand']}&quot;&#10;            }&#10;            &#10;            teams_data['meetings'].append(meeting)&#10;        &#10;        with open(output_file, 'w', encoding='utf-8') as f:&#10;            json.dump(teams_data, f, indent=2, ensure_ascii=False)&#10;        &#10;        print(f&quot; Teams integration file exported to: {output_file}&quot;)&#10;    &#10;    def export_statistics_report(self, output_file: str):&#10;        &quot;&quot;&quot;Export detailed statistics report.&quot;&quot;&quot;&#10;        stats = self._calculate_statistics()&#10;        &#10;        report_lines = [&#10;            &quot; TIMETABLE STATISTICS REPORT&quot;,&#10;            &quot;=&quot; * 50,&#10;            f&quot;Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&quot;,&#10;            f&quot;Schedule: {self.meta.get('week_name', 'Unknown')}&quot;,&#10;            f&quot;Total Events: {len(self.assignments)}&quot;,&#10;            &quot;&quot;,&#10;            &quot; RESOURCE UTILIZATION&quot;,&#10;            &quot;-&quot; * 30&#10;        ]&#10;        &#10;        # Teacher statistics&#10;        report_lines.extend([&#10;            f&quot;Teachers: {stats['unique_teachers']} teachers&quot;,&#10;            f&quot;Average events per teacher: {stats['avg_events_per_teacher']:.1f}&quot;,&#10;            f&quot;Teacher workload range: {stats['teacher_workload_range']}&quot;,&#10;            &quot;&quot;&#10;        ])&#10;        &#10;        # Room statistics&#10;        report_lines.extend([&#10;            f&quot;Rooms: {stats['unique_rooms']} rooms used&quot;,&#10;            f&quot;Average room utilization: {stats['avg_room_utilization']:.1%}&quot;,&#10;            f&quot;Most used room: {stats['most_used_room']} ({stats['most_used_room_count']} events)&quot;,&#10;            &quot;&quot;&#10;        ])&#10;        &#10;        # Time distribution&#10;        report_lines.extend([&#10;            &quot;⏰ TIME DISTRIBUTION&quot;,&#10;            &quot;-&quot; * 25&#10;        ])&#10;        &#10;        for day, count in stats['events_per_day'].items():&#10;            report_lines.append(f&quot;{day}: {count} events&quot;)&#10;        &#10;        report_lines.extend([&#10;            &quot;&quot;,&#10;            f&quot;Peak day: {stats['peak_day']} ({stats['peak_day_events']} events)&quot;,&#10;            f&quot;Average events per day: {stats['avg_events_per_day']:.1f}&quot;,&#10;            &quot;&quot;&#10;        ])&#10;        &#10;        # Module statistics&#10;        report_lines.extend([&#10;            &quot; MODULE STATISTICS&quot;,&#10;            &quot;-&quot; * 25,&#10;            f&quot;Total modules: {stats['unique_modules']}&quot;,&#10;            f&quot;Average hours per module: {stats['avg_hours_per_module']:.1f}h/week&quot;&#10;        ])&#10;        &#10;        with open(output_file, 'w', encoding='utf-8') as f:&#10;            f.write('\\n'.join(report_lines))&#10;        &#10;        print(f&quot; Statistics report exported to: {output_file}&quot;)&#10;    &#10;    def _calculate_statistics(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calculate comprehensive statistics.&quot;&quot;&quot;&#10;        if not self.assignments:&#10;            return {}&#10;        &#10;        # Basic counts&#10;        unique_teachers = set(a['teacher_id'] for a in self.assignments)&#10;        unique_rooms = set(a['room_id'] for a in self.assignments)&#10;        unique_modules = set(a['module_id'] for a in self.assignments)&#10;        &#10;        # Teacher workload&#10;        teacher_workload = {}&#10;        for assignment in self.assignments:&#10;            teacher = assignment['teacher_id']&#10;            hours = assignment.get('duration_hours', 0)&#10;            teacher_workload[teacher] = teacher_workload.get(teacher, 0) + hours&#10;        &#10;        # Room utilization&#10;        room_usage = {}&#10;        for assignment in self.assignments:&#10;            room = assignment['room_id']&#10;            room_usage[room] = room_usage.get(room, 0) + 1&#10;        &#10;        # Time distribution&#10;        events_per_day = {}&#10;        for assignment in self.assignments:&#10;            day = assignment['timeslot_id'].split('_')[0]&#10;            events_per_day[day] = events_per_day.get(day, 0) + 1&#10;        &#10;        # Module hours&#10;        module_hours = {}&#10;        for assignment in self.assignments:&#10;            module = assignment['module_id']&#10;            hours = assignment.get('module_hours_per_week', 0)&#10;            if hours &gt; 0:&#10;                module_hours[module] = hours&#10;        &#10;        return {&#10;            'unique_teachers': len(unique_teachers),&#10;            'unique_rooms': len(unique_rooms),&#10;            'unique_modules': len(unique_modules),&#10;            'avg_events_per_teacher': len(self.assignments) / len(unique_teachers) if unique_teachers else 0,&#10;            'teacher_workload_range': f&quot;{min(teacher_workload.values()):.1f}h - {max(teacher_workload.values()):.1f}h&quot; if teacher_workload else &quot;0h&quot;,&#10;            'avg_room_utilization': len(self.assignments) / len(unique_rooms) if unique_rooms else 0,&#10;            'most_used_room': max(room_usage, key=room_usage.get) if room_usage else &quot;None&quot;,&#10;            'most_used_room_count': max(room_usage.values()) if room_usage else 0,&#10;            'events_per_day': events_per_day,&#10;            'peak_day': max(events_per_day, key=events_per_day.get) if events_per_day else &quot;None&quot;,&#10;            'peak_day_events': max(events_per_day.values()) if events_per_day else 0,&#10;            'avg_events_per_day': sum(events_per_day.values()) / len(events_per_day) if events_per_day else 0,&#10;            'avg_hours_per_module': sum(module_hours.values()) / len(module_hours) if module_hours else 0&#10;        }&#10;    &#10;    def export_all_formats(self, base_filename: str):&#10;        &quot;&quot;&quot;Export to all available formats.&quot;&quot;&quot;&#10;        base_name = base_filename.rsplit('.', 1)[0]&#10;        &#10;        print(&quot; Exporting to all formats...&quot;)&#10;        &#10;        try:&#10;            self.export_csv(f&quot;{base_name}.csv&quot;)&#10;            self.export_enhanced_json(f&quot;{base_name}_enhanced.json&quot;)&#10;            self.export_xml(f&quot;{base_name}.xml&quot;)&#10;            self.export_ical(f&quot;{base_name}.ics&quot;)&#10;            self.export_moodle_xml(f&quot;{base_name}_moodle.xml&quot;)&#10;            self.export_teams_integration(f&quot;{base_name}_teams.json&quot;)&#10;            self.export_statistics_report(f&quot;{base_name}_stats.txt&quot;)&#10;            &#10;            print(&quot;✅ All formats exported successfully!&quot;)&#10;            &#10;        except Exception as e:&#10;            print(f&quot;❌ Error during export: {e}&quot;)&#10;&#10;def load_and_export(json_file: str, formats: List[str] = None, output_prefix: str = &quot;timetable&quot;):&#10;    &quot;&quot;&quot;Load timetable data and export to specified formats.&quot;&quot;&quot;&#10;    if formats is None:&#10;        formats = ['csv', 'ical', 'xml']&#10;    &#10;    try:&#10;        with open(json_file, 'r', encoding='utf-8') as f:&#10;            data = json.load(f)&#10;        &#10;        exporter = EnhancedTimetableExporter(data)&#10;        &#10;        for format_name in formats:&#10;            if format_name == 'csv':&#10;                exporter.export_csv(f&quot;{output_prefix}.csv&quot;)&#10;            elif format_name == 'ical':&#10;                exporter.export_ical(f&quot;{output_prefix}.ics&quot;)&#10;            elif format_name == 'xml':&#10;                exporter.export_xml(f&quot;{output_prefix}.xml&quot;)&#10;            elif format_name == 'json':&#10;                exporter.export_enhanced_json(f&quot;{output_prefix}_enhanced.json&quot;)&#10;            elif format_name == 'moodle':&#10;                exporter.export_moodle_xml(f&quot;{output_prefix}_moodle.xml&quot;)&#10;            elif format_name == 'teams':&#10;                exporter.export_teams_integration(f&quot;{output_prefix}_teams.json&quot;)&#10;            elif format_name == 'stats':&#10;                exporter.export_statistics_report(f&quot;{output_prefix}_stats.txt&quot;)&#10;            elif format_name == 'all':&#10;                exporter.export_all_formats(output_prefix)&#10;                break&#10;            else:&#10;                print(f&quot;⚠️ Unknown format: {format_name}&quot;)&#10;    &#10;    except Exception as e:&#10;        print(f&quot;❌ Error loading or exporting: {e}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    print(&quot; Enhanced Timetable Exporter&quot;)&#10;    print(&quot;Usage: load_and_export('timetable_output.json', ['csv', 'ical', 'xml'])&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_preferences.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_preferences.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Advanced preference and soft constraint system for timetabling.&#10;Allows optimization based on preferences rather than just finding any feasible solution.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;from dataclasses import dataclass&#10;from typing import Dict, List, Optional, FrozenSet, Tuple&#10;from enum import Enum&#10;&#10;class PreferenceType(Enum):&#10;    &quot;&quot;&quot;Types of scheduling preferences.&quot;&quot;&quot;&#10;    TEACHER_PREFERRED_TIMES = &quot;teacher_preferred_times&quot;&#10;    ROOM_PREFERRED_USAGE = &quot;room_preferred_usage&quot; &#10;    GROUP_PREFERRED_TIMES = &quot;group_preferred_times&quot;&#10;    EVENT_SPACING = &quot;event_spacing&quot;&#10;    DAY_COMPACTNESS = &quot;day_compactness&quot;&#10;    LUNCH_BREAK = &quot;lunch_break&quot;&#10;    AVOID_LATE_CLASSES = &quot;avoid_late_classes&quot;&#10;    MINIMIZE_ROOM_CHANGES = &quot;minimize_room_changes&quot;&#10;&#10;@dataclass&#10;class Preference:&#10;    &quot;&quot;&quot;A scheduling preference with weight and parameters.&quot;&quot;&quot;&#10;    type: PreferenceType&#10;    weight: float  # 0.0 to 1.0, higher = more important&#10;    target: str  # teacher_id, room_id, group_id, or event_id&#10;    parameters: Dict[str, any]&#10;    description: str&#10;&#10;class PreferenceManager:&#10;    &quot;&quot;&quot;Manages and evaluates scheduling preferences.&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.preferences: List[Preference] = []&#10;    &#10;    def add_teacher_preference(self, teacher_id: str, preferred_slots: List[str], &#10;                             weight: float = 0.7, description: str = &quot;&quot;):&#10;        &quot;&quot;&quot;Add teacher's preferred time slots.&quot;&quot;&quot;&#10;        self.preferences.append(Preference(&#10;            type=PreferenceType.TEACHER_PREFERRED_TIMES,&#10;            weight=weight,&#10;            target=teacher_id,&#10;            parameters={&quot;preferred_slots&quot;: preferred_slots},&#10;            description=description or f&quot;Teacher {teacher_id} prefers certain time slots&quot;&#10;        ))&#10;    &#10;    def add_lunch_break_preference(self, start_time: str = &quot;12:00&quot;, end_time: str = &quot;14:00&quot;, &#10;                                 weight: float = 0.8):&#10;        &quot;&quot;&quot;Prefer to keep lunch break free.&quot;&quot;&quot;&#10;        self.preferences.append(Preference(&#10;            type=PreferenceType.LUNCH_BREAK,&#10;            weight=weight,&#10;            target=&quot;all&quot;,&#10;            parameters={&quot;start_time&quot;: start_time, &quot;end_time&quot;: end_time},&#10;            description=f&quot;Prefer lunch break {start_time}-{end_time} free&quot;&#10;        ))&#10;    &#10;    def add_compact_day_preference(self, group_id: str, weight: float = 0.6):&#10;        &quot;&quot;&quot;Prefer compact schedules (minimize gaps between classes).&quot;&quot;&quot;&#10;        self.preferences.append(Preference(&#10;            type=PreferenceType.DAY_COMPACTNESS,&#10;            weight=weight,&#10;            target=group_id,&#10;            parameters={},&#10;            description=f&quot;Prefer compact schedule for {group_id}&quot;&#10;        ))&#10;    &#10;    def add_avoid_late_classes_preference(self, cutoff_time: str = &quot;18:00&quot;, weight: float = 0.5):&#10;        &quot;&quot;&quot;Avoid scheduling classes after certain time.&quot;&quot;&quot;&#10;        self.preferences.append(Preference(&#10;            type=PreferenceType.AVOID_LATE_CLASSES,&#10;            weight=weight,&#10;            target=&quot;all&quot;,&#10;            parameters={&quot;cutoff_time&quot;: cutoff_time},&#10;            description=f&quot;Avoid classes after {cutoff_time}&quot;&#10;        ))&#10;    &#10;    def evaluate_schedule_quality(self, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate how well a schedule satisfies preferences (0.0 to 1.0).&quot;&quot;&quot;&#10;        total_score = 0.0&#10;        total_weight = 0.0&#10;        &#10;        for preference in self.preferences:&#10;            score = self._evaluate_preference(preference, assignment, problem)&#10;            total_score += score * preference.weight&#10;            total_weight += preference.weight&#10;        &#10;        return total_score / total_weight if total_weight &gt; 0 else 1.0&#10;    &#10;    def _evaluate_preference(self, preference: Preference, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate a single preference (0.0 = worst, 1.0 = best).&quot;&quot;&quot;&#10;        if preference.type == PreferenceType.TEACHER_PREFERRED_TIMES:&#10;            return self._evaluate_teacher_preferred_times(preference, assignment, problem)&#10;        elif preference.type == PreferenceType.LUNCH_BREAK:&#10;            return self._evaluate_lunch_break(preference, assignment, problem)&#10;        elif preference.type == PreferenceType.DAY_COMPACTNESS:&#10;            return self._evaluate_day_compactness(preference, assignment, problem)&#10;        elif preference.type == PreferenceType.AVOID_LATE_CLASSES:&#10;            return self._evaluate_avoid_late_classes(preference, assignment, problem)&#10;        else:&#10;            return 1.0  # Unknown preference type&#10;    &#10;    def _evaluate_teacher_preferred_times(self, preference: Preference, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate how well teacher's preferred times are used.&quot;&quot;&quot;&#10;        teacher_id = preference.target&#10;        preferred_slots = set(preference.parameters[&quot;preferred_slots&quot;])&#10;        &#10;        teacher_assignments = [&#10;            (eid, tid, rid) for eid, tid, rid in assignment&#10;            if problem.events[eid].teacher_id == teacher_id&#10;        ]&#10;        &#10;        if not teacher_assignments:&#10;            return 1.0  # No assignments for this teacher&#10;        &#10;        preferred_count = sum(1 for _, tid, _ in teacher_assignments if tid in preferred_slots)&#10;        return preferred_count / len(teacher_assignments)&#10;    &#10;    def _evaluate_lunch_break(self, preference: Preference, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate lunch break preservation.&quot;&quot;&quot;&#10;        start_time = preference.parameters[&quot;start_time&quot;]&#10;        end_time = preference.parameters[&quot;end_time&quot;]&#10;        &#10;        lunch_violations = 0&#10;        total_slots = 0&#10;        &#10;        for _, tid, _ in assignment:&#10;            timeslot = problem.timeslots[tid]&#10;            total_slots += 1&#10;            &#10;            # Check if this slot conflicts with lunch time&#10;            if self._time_overlaps_lunch(timeslot.start, timeslot.end, start_time, end_time):&#10;                lunch_violations += 1&#10;        &#10;        return 1.0 - (lunch_violations / total_slots) if total_slots &gt; 0 else 1.0&#10;    &#10;    def _evaluate_day_compactness(self, preference: Preference, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate schedule compactness for a group.&quot;&quot;&quot;&#10;        group_id = preference.target&#10;        &#10;        # Group assignments by day for this group&#10;        day_assignments = {}&#10;        for eid, tid, _ in assignment:&#10;            event = problem.events[eid]&#10;            if group_id in event.group_ids:&#10;                timeslot = problem.timeslots[tid]&#10;                day = timeslot.day&#10;                if day not in day_assignments:&#10;                    day_assignments[day] = []&#10;                day_assignments[day].append(timeslot.start)&#10;        &#10;        # Calculate compactness score for each day&#10;        total_gap_penalty = 0.0&#10;        total_days = len(day_assignments)&#10;        &#10;        for day, start_times in day_assignments.items():&#10;            if len(start_times) &gt; 1:&#10;                start_times.sort()&#10;                # Penalize gaps between classes&#10;                gaps = 0&#10;                for i in range(1, len(start_times)):&#10;                    # Simple gap detection (could be more sophisticated)&#10;                    gaps += 1 if self._has_large_gap(start_times[i-1], start_times[i]) else 0&#10;                total_gap_penalty += gaps / (len(start_times) - 1)&#10;        &#10;        return 1.0 - (total_gap_penalty / total_days) if total_days &gt; 0 else 1.0&#10;    &#10;    def _evaluate_avoid_late_classes(self, preference: Preference, assignment, problem) -&gt; float:&#10;        &quot;&quot;&quot;Evaluate avoidance of late classes.&quot;&quot;&quot;&#10;        cutoff_time = preference.parameters[&quot;cutoff_time&quot;]&#10;        &#10;        late_classes = 0&#10;        total_classes = len(assignment)&#10;        &#10;        for _, tid, _ in assignment:&#10;            timeslot = problem.timeslots[tid]&#10;            if timeslot.start &gt;= cutoff_time:&#10;                late_classes += 1&#10;        &#10;        return 1.0 - (late_classes / total_classes) if total_classes &gt; 0 else 1.0&#10;    &#10;    def _time_overlaps_lunch(self, start: str, end: str, lunch_start: str, lunch_end: str) -&gt; bool:&#10;        &quot;&quot;&quot;Check if time slot overlaps with lunch break.&quot;&quot;&quot;&#10;        # Simple string comparison (assumes HH:MM format)&#10;        return not (end &lt;= lunch_start or start &gt;= lunch_end)&#10;    &#10;    def _has_large_gap(self, time1: str, time2: str) -&gt; bool:&#10;        &quot;&quot;&quot;Check if there's a large gap between two time slots.&quot;&quot;&quot;&#10;        # Simple heuristic: gap &gt; 2 hours&#10;        # In real implementation, would parse times properly&#10;        return abs(int(time1.split(':')[0]) - int(time2.split(':')[0])) &gt; 2&#10;&#10;def load_preferences_from_json(preferences_data: Dict) -&gt; PreferenceManager:&#10;    &quot;&quot;&quot;Load preferences from JSON configuration.&quot;&quot;&quot;&#10;    manager = PreferenceManager()&#10;    &#10;    # Teacher preferences&#10;    for teacher_pref in preferences_data.get(&quot;teacher_preferences&quot;, []):&#10;        manager.add_teacher_preference(&#10;            teacher_id=teacher_pref[&quot;teacher_id&quot;],&#10;            preferred_slots=teacher_pref[&quot;preferred_slots&quot;],&#10;            weight=teacher_pref.get(&quot;weight&quot;, 0.7),&#10;            description=teacher_pref.get(&quot;description&quot;, &quot;&quot;)&#10;        )&#10;    &#10;    # Global preferences&#10;    if &quot;lunch_break&quot; in preferences_data:&#10;        lunch = preferences_data[&quot;lunch_break&quot;]&#10;        manager.add_lunch_break_preference(&#10;            start_time=lunch.get(&quot;start_time&quot;, &quot;12:00&quot;),&#10;            end_time=lunch.get(&quot;end_time&quot;, &quot;14:00&quot;),&#10;            weight=lunch.get(&quot;weight&quot;, 0.8)&#10;        )&#10;    &#10;    # Group preferences&#10;    for group_pref in preferences_data.get(&quot;group_preferences&quot;, []):&#10;        if group_pref.get(&quot;type&quot;) == &quot;compact&quot;:&#10;            manager.add_compact_day_preference(&#10;                group_id=group_pref[&quot;group_id&quot;],&#10;                weight=group_pref.get(&quot;weight&quot;, 0.6)&#10;            )&#10;    &#10;    # Global time preferences&#10;    if &quot;avoid_late_classes&quot; in preferences_data:&#10;        late_pref = preferences_data[&quot;avoid_late_classes&quot;]&#10;        manager.add_avoid_late_classes_preference(&#10;            cutoff_time=late_pref.get(&quot;cutoff_time&quot;, &quot;18:00&quot;),&#10;            weight=late_pref.get(&quot;weight&quot;, 0.5)&#10;        )&#10;    &#10;    return manager" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/timetable_validation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_validation.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Schedule validation and quality assessment system.&#10;Provides comprehensive analysis of schedule quality and adherence to best practices.&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;from dataclasses import dataclass&#10;from typing import Dict, List, Set, Tuple, Optional&#10;import statistics&#10;from datetime import datetime, time&#10;&#10;@dataclass&#10;class QualityMetric:&#10;    &quot;&quot;&quot;Represents a quality metric with score and details.&quot;&quot;&quot;&#10;    name: str&#10;    score: float  # 0.0 to 1.0 (1.0 = perfect)&#10;    max_score: float&#10;    description: str&#10;    details: Dict[str, any] = None&#10;&#10;@dataclass &#10;class ScheduleQualityReport:&#10;    &quot;&quot;&quot;Comprehensive quality assessment of a schedule.&quot;&quot;&quot;&#10;    overall_score: float&#10;    metrics: List[QualityMetric]&#10;    recommendations: List[str]&#10;    strengths: List[str]&#10;    weaknesses: List[str]&#10;&#10;class ScheduleValidator:&#10;    &quot;&quot;&quot;Validates and assesses schedule quality.&quot;&quot;&quot;&#10;    &#10;    def __init__(self, problem):&#10;        self.problem = problem&#10;    &#10;    def validate_and_assess(self, assignment) -&gt; ScheduleQualityReport:&#10;        &quot;&quot;&quot;Comprehensive schedule validation and quality assessment.&quot;&quot;&quot;&#10;        metrics = []&#10;        &#10;        # Core validation metrics&#10;        metrics.append(self._assess_constraint_adherence(assignment))&#10;        metrics.append(self._assess_resource_utilization(assignment))&#10;        metrics.append(self._assess_time_distribution(assignment))&#10;        metrics.append(self._assess_workload_balance(assignment))&#10;        metrics.append(self._assess_schedule_compactness(assignment))&#10;        metrics.append(self._assess_room_efficiency(assignment))&#10;        metrics.append(self._assess_teacher_satisfaction(assignment))&#10;        metrics.append(self._assess_student_convenience(assignment))&#10;        &#10;        # Calculate overall score&#10;        overall_score = sum(m.score * m.max_score for m in metrics) / sum(m.max_score for m in metrics)&#10;        &#10;        # Generate recommendations, strengths, and weaknesses&#10;        recommendations = self._generate_recommendations(metrics, assignment)&#10;        strengths = self._identify_strengths(metrics)&#10;        weaknesses = self._identify_weaknesses(metrics)&#10;        &#10;        return ScheduleQualityReport(&#10;            overall_score=overall_score,&#10;            metrics=metrics,&#10;            recommendations=recommendations,&#10;            strengths=strengths,&#10;            weaknesses=weaknesses&#10;        )&#10;    &#10;    def _assess_constraint_adherence(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess adherence to hard constraints.&quot;&quot;&quot;&#10;        violations = 0&#10;        total_checks = 0&#10;        &#10;        # Check all hard constraints&#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            room = self.problem.rooms[rid]&#10;            teacher = self.problem.teachers[event.teacher_id]&#10;            &#10;            total_checks += 4  # duration, teacher avail, room avail, capacity&#10;            &#10;            # Duration match&#10;            if event.duration_min != timeslot.duration_min:&#10;                violations += 1&#10;            &#10;            # Teacher availability&#10;            if tid not in teacher.available:&#10;                violations += 1&#10;                &#10;            # Room availability  &#10;            if tid not in room.available:&#10;                violations += 1&#10;                &#10;            # Capacity check&#10;            required_capacity = max(&#10;                sum(self.problem.groups[gid].size for gid in event.group_ids),&#10;                event.min_room_capacity&#10;            )&#10;            if required_capacity &gt; room.capacity:&#10;                violations += 1&#10;        &#10;        score = 1.0 - (violations / total_checks) if total_checks &gt; 0 else 1.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Constraint Adherence&quot;,&#10;            score=score,&#10;            max_score=1.0,&#10;            description=f&quot;Hard constraint violations: {violations}/{total_checks}&quot;,&#10;            details={&quot;violations&quot;: violations, &quot;total_checks&quot;: total_checks}&#10;        )&#10;    &#10;    def _assess_resource_utilization(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess efficiency of resource utilization.&quot;&quot;&quot;&#10;        # Room utilization&#10;        room_usage = {}&#10;        timeslot_count = len(self.problem.timeslots_list)&#10;        &#10;        for eid, tid, rid in assignment:&#10;            if rid not in room_usage:&#10;                room_usage[rid] = 0&#10;            room_usage[rid] += 1&#10;        &#10;        # Calculate utilization rates&#10;        utilization_rates = []&#10;        for room in self.problem.rooms_list:&#10;            available_slots = len(room.available)&#10;            used_slots = room_usage.get(room.id, 0)&#10;            if available_slots &gt; 0:&#10;                utilization_rates.append(used_slots / available_slots)&#10;        &#10;        avg_utilization = statistics.mean(utilization_rates) if utilization_rates else 0.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Resource Utilization&quot;,&#10;            score=min(avg_utilization * 1.5, 1.0),  # Reward good utilization&#10;            max_score=1.0,&#10;            description=f&quot;Average room utilization: {avg_utilization:.1%}&quot;,&#10;            details={&quot;room_utilization&quot;: room_usage, &quot;average&quot;: avg_utilization}&#10;        )&#10;    &#10;    def _assess_time_distribution(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess distribution of events across time slots.&quot;&quot;&quot;&#10;        timeslot_usage = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            if tid not in timeslot_usage:&#10;                timeslot_usage[tid] = 0&#10;            timeslot_usage[tid] += 1&#10;        &#10;        # Calculate distribution evenness (lower std dev = more even)&#10;        usage_values = list(timeslot_usage.values())&#10;        if len(usage_values) &gt; 1:&#10;            mean_usage = statistics.mean(usage_values)&#10;            std_dev = statistics.stdev(usage_values)&#10;            evenness = 1.0 - min(std_dev / mean_usage, 1.0) if mean_usage &gt; 0 else 1.0&#10;        else:&#10;            evenness = 1.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Time Distribution&quot;,&#10;            score=evenness,&#10;            max_score=0.8,&#10;            description=f&quot;Event distribution evenness: {evenness:.1%}&quot;,&#10;            details={&quot;timeslot_usage&quot;: timeslot_usage, &quot;evenness&quot;: evenness}&#10;        )&#10;    &#10;    def _assess_workload_balance(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess balance of workload across teachers and groups.&quot;&quot;&quot;&#10;        teacher_loads = {}&#10;        group_loads = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            &#10;            # Teacher workload&#10;            if event.teacher_id not in teacher_loads:&#10;                teacher_loads[event.teacher_id] = 0&#10;            teacher_loads[event.teacher_id] += event.duration_min / 60.0&#10;            &#10;            # Group workload&#10;            for gid in event.group_ids:&#10;                if gid not in group_loads:&#10;                    group_loads[gid] = 0&#10;                group_loads[gid] += event.duration_min / 60.0&#10;        &#10;        # Calculate balance (lower coefficient of variation = better balance)&#10;        def calculate_balance(loads):&#10;            values = list(loads.values())&#10;            if len(values) &lt;= 1:&#10;                return 1.0&#10;            mean_load = statistics.mean(values)&#10;            if mean_load == 0:&#10;                return 1.0&#10;            std_dev = statistics.stdev(values)&#10;            cv = std_dev / mean_load&#10;            return max(0.0, 1.0 - cv)&#10;        &#10;        teacher_balance = calculate_balance(teacher_loads)&#10;        group_balance = calculate_balance(group_loads)&#10;        overall_balance = (teacher_balance + group_balance) / 2.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Workload Balance&quot;,&#10;            score=overall_balance,&#10;            max_score=0.9,&#10;            description=f&quot;Teacher balance: {teacher_balance:.1%}, Group balance: {group_balance:.1%}&quot;,&#10;            details={&#10;                &quot;teacher_loads&quot;: teacher_loads,&#10;                &quot;group_loads&quot;: group_loads,&#10;                &quot;teacher_balance&quot;: teacher_balance,&#10;                &quot;group_balance&quot;: group_balance&#10;            }&#10;        )&#10;    &#10;    def _assess_schedule_compactness(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess compactness of schedules (fewer gaps).&quot;&quot;&quot;&#10;        # Group events by entity and day&#10;        daily_schedules = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            day = timeslot.day&#10;            &#10;            # Track for each group&#10;            for gid in event.group_ids:&#10;                key = f&quot;{gid}_{day}&quot;&#10;                if key not in daily_schedules:&#10;                    daily_schedules[key] = []&#10;                daily_schedules[key].append(timeslot.start)&#10;        &#10;        # Calculate compactness score&#10;        total_gaps = 0&#10;        total_possible_gaps = 0&#10;        &#10;        for key, times in daily_schedules.items():&#10;            if len(times) &lt;= 1:&#10;                continue&#10;                &#10;            times.sort()&#10;            possible_gaps = len(times) - 1&#10;            total_possible_gaps += possible_gaps&#10;            &#10;            # Count actual gaps (simplified - assumes 2+ hour gaps are bad)&#10;            gaps = 0&#10;            for i in range(1, len(times)):&#10;                hour1 = int(times[i-1].split(':')[0])&#10;                hour2 = int(times[i].split(':')[0])&#10;                if hour2 - hour1 &gt; 2:  # More than 2-hour gap&#10;                    gaps += 1&#10;            total_gaps += gaps&#10;        &#10;        compactness = 1.0 - (total_gaps / total_possible_gaps) if total_possible_gaps &gt; 0 else 1.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Schedule Compactness&quot;,&#10;            score=compactness,&#10;            max_score=0.7,&#10;            description=f&quot;Schedule compactness: {compactness:.1%} (fewer gaps is better)&quot;,&#10;            details={&quot;total_gaps&quot;: total_gaps, &quot;possible_gaps&quot;: total_possible_gaps}&#10;        )&#10;    &#10;    def _assess_room_efficiency(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess efficiency of room assignments.&quot;&quot;&quot;&#10;        room_utilization_efficiency = []&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            room = self.problem.rooms[rid]&#10;            &#10;            # Calculate required vs actual capacity&#10;            required = max(&#10;                sum(self.problem.groups[gid].size for gid in event.group_ids),&#10;                event.min_room_capacity&#10;            )&#10;            &#10;            if room.capacity &gt; 0:&#10;                efficiency = required / room.capacity&#10;                room_utilization_efficiency.append(min(efficiency, 1.0))&#10;        &#10;        avg_efficiency = statistics.mean(room_utilization_efficiency) if room_utilization_efficiency else 0.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Room Efficiency&quot;, &#10;            score=avg_efficiency,&#10;            max_score=0.6,&#10;            description=f&quot;Average room space efficiency: {avg_efficiency:.1%}&quot;,&#10;            details={&quot;efficiency_scores&quot;: room_utilization_efficiency}&#10;        )&#10;    &#10;    def _assess_teacher_satisfaction(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess teacher satisfaction factors.&quot;&quot;&quot;&#10;        teacher_metrics = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            teacher_id = event.teacher_id&#10;            &#10;            if teacher_id not in teacher_metrics:&#10;                teacher_metrics[teacher_id] = {&#10;                    &quot;total_hours&quot;: 0,&#10;                    &quot;days_worked&quot;: set(),&#10;                    &quot;late_classes&quot;: 0,&#10;                    &quot;early_classes&quot;: 0&#10;                }&#10;            &#10;            metrics = teacher_metrics[teacher_id]&#10;            metrics[&quot;total_hours&quot;] += event.duration_min / 60.0&#10;            metrics[&quot;days_worked&quot;].add(timeslot.day)&#10;            &#10;            # Check for early/late classes&#10;            hour = int(timeslot.start.split(':')[0])&#10;            if hour &lt; 8:&#10;                metrics[&quot;early_classes&quot;] += 1&#10;            elif hour &gt;= 18:&#10;                metrics[&quot;late_classes&quot;] += 1&#10;        &#10;        # Calculate satisfaction score&#10;        satisfaction_scores = []&#10;        for teacher_id, metrics in teacher_metrics.items():&#10;            score = 1.0&#10;            &#10;            # Penalize too many days&#10;            if len(metrics[&quot;days_worked&quot;]) &gt; 4:&#10;                score -= 0.2&#10;                &#10;            # Penalize early/late classes&#10;            total_classes = len([a for a in assignment if self.problem.events[a[0]].teacher_id == teacher_id])&#10;            if total_classes &gt; 0:&#10;                score -= (metrics[&quot;early_classes&quot;] + metrics[&quot;late_classes&quot;]) * 0.1 / total_classes&#10;            &#10;            satisfaction_scores.append(max(score, 0.0))&#10;        &#10;        avg_satisfaction = statistics.mean(satisfaction_scores) if satisfaction_scores else 1.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Teacher Satisfaction&quot;,&#10;            score=avg_satisfaction,&#10;            max_score=0.6,&#10;            description=f&quot;Average teacher satisfaction: {avg_satisfaction:.1%}&quot;,&#10;            details={&quot;teacher_metrics&quot;: teacher_metrics}&#10;        )&#10;    &#10;    def _assess_student_convenience(self, assignment) -&gt; QualityMetric:&#10;        &quot;&quot;&quot;Assess convenience factors for students.&quot;&quot;&quot;&#10;        group_convenience = {}&#10;        &#10;        for eid, tid, rid in assignment:&#10;            event = self.problem.events[eid]&#10;            timeslot = self.problem.timeslots[tid]&#10;            &#10;            for gid in event.group_ids:&#10;                if gid not in group_convenience:&#10;                    group_convenience[gid] = {&#10;                        &quot;days_with_classes&quot;: set(),&#10;                        &quot;room_changes&quot;: [],&#10;                        &quot;early_classes&quot;: 0,&#10;                        &quot;late_classes&quot;: 0&#10;                    }&#10;                &#10;                conv = group_convenience[gid]&#10;                conv[&quot;days_with_classes&quot;].add(timeslot.day)&#10;                conv[&quot;room_changes&quot;].append(rid)&#10;                &#10;                # Check timing&#10;                hour = int(timeslot.start.split(':')[0])&#10;                if hour &lt; 8:&#10;                    conv[&quot;early_classes&quot;] += 1&#10;                elif hour &gt;= 18:&#10;                    conv[&quot;late_classes&quot;] += 1&#10;        &#10;        # Calculate convenience scores&#10;        convenience_scores = []&#10;        for gid, conv in group_convenience.items():&#10;            score = 1.0&#10;            &#10;            # Reward fewer days with classes&#10;            days_count = len(conv[&quot;days_with_classes&quot;])&#10;            if days_count &lt;= 3:&#10;                score += 0.1&#10;            elif days_count &gt; 5:&#10;                score -= 0.2&#10;            &#10;            # Penalize too many room changes&#10;            unique_rooms = len(set(conv[&quot;room_changes&quot;]))&#10;            if unique_rooms &gt; 3:&#10;                score -= 0.1&#10;            &#10;            # Penalize early/late classes&#10;            total_classes = len(conv[&quot;room_changes&quot;])&#10;            if total_classes &gt; 0:&#10;                inconvenient = conv[&quot;early_classes&quot;] + conv[&quot;late_classes&quot;]&#10;                score -= inconvenient * 0.15 / total_classes&#10;            &#10;            convenience_scores.append(max(score, 0.0))&#10;        &#10;        avg_convenience = statistics.mean(convenience_scores) if convenience_scores else 1.0&#10;        &#10;        return QualityMetric(&#10;            name=&quot;Student Convenience&quot;,&#10;            score=min(avg_convenience, 1.0),&#10;            max_score=0.5,&#10;            description=f&quot;Average student convenience: {min(avg_convenience, 1.0):.1%}&quot;,&#10;            details={&quot;group_convenience&quot;: group_convenience}&#10;        )&#10;    &#10;    def _generate_recommendations(self, metrics: List[QualityMetric], assignment) -&gt; List[str]:&#10;        &quot;&quot;&quot;Generate specific recommendations based on metrics.&quot;&quot;&quot;&#10;        recommendations = []&#10;        &#10;        # Low constraint adherence&#10;        constraint_metric = next((m for m in metrics if m.name == &quot;Constraint Adherence&quot;), None)&#10;        if constraint_metric and constraint_metric.score &lt; 0.8:&#10;            recommendations.append(&quot; Address hard constraint violations first - these make the schedule invalid&quot;)&#10;        &#10;        # Poor resource utilization&#10;        resource_metric = next((m for m in metrics if m.name == &quot;Resource Utilization&quot;), None)&#10;        if resource_metric and resource_metric.score &lt; 0.4:&#10;            recommendations.append(&quot; Consider adding more events to better utilize available rooms and time slots&quot;)&#10;        &#10;        # Poor workload balance&#10;        balance_metric = next((m for m in metrics if m.name == &quot;Workload Balance&quot;), None)&#10;        if balance_metric and balance_metric.score &lt; 0.6:&#10;            recommendations.append(&quot;⚖️ Redistribute workload more evenly across teachers and student groups&quot;)&#10;        &#10;        # Poor compactness&#10;        compact_metric = next((m for m in metrics if m.name == &quot;Schedule Compactness&quot;), None)&#10;        if compact_metric and compact_metric.score &lt; 0.5:&#10;            recommendations.append(&quot;️ Reduce gaps between classes by scheduling consecutive time slots&quot;)&#10;        &#10;        # Low room efficiency&#10;        room_metric = next((m for m in metrics if m.name == &quot;Room Efficiency&quot;), None)&#10;        if room_metric and room_metric.score &lt; 0.6:&#10;            recommendations.append(&quot; Use appropriately sized rooms - avoid large rooms for small classes&quot;)&#10;        &#10;        # Teacher satisfaction issues&#10;        teacher_metric = next((m for m in metrics if m.name == &quot;Teacher Satisfaction&quot;), None)&#10;        if teacher_metric and teacher_metric.score &lt; 0.7:&#10;            recommendations.append(&quot;‍ Improve teacher schedules - reduce early/late classes and spread across fewer days&quot;)&#10;        &#10;        return recommendations&#10;    &#10;    def _identify_strengths(self, metrics: List[QualityMetric]) -&gt; List[str]:&#10;        &quot;&quot;&quot;Identify strengths in the schedule.&quot;&quot;&quot;&#10;        strengths = []&#10;        &#10;        for metric in metrics:&#10;            if metric.score &gt;= 0.8:&#10;                strengths.append(f&quot;✅ {metric.name}: {metric.description}&quot;)&#10;        &#10;        return strengths&#10;    &#10;    def _identify_weaknesses(self, metrics: List[QualityMetric]) -&gt; List[str]:&#10;        &quot;&quot;&quot;Identify weaknesses in the schedule.&quot;&quot;&quot;&#10;        weaknesses = []&#10;        &#10;        for metric in metrics:&#10;            if metric.score &lt; 0.6:&#10;                weaknesses.append(f&quot;⚠️ {metric.name}: {metric.description}&quot;)&#10;        &#10;        return weaknesses&#10;&#10;def generate_quality_report(report: ScheduleQualityReport) -&gt; str:&#10;    &quot;&quot;&quot;Generate a human-readable quality report.&quot;&quot;&quot;&#10;    lines = []&#10;    &#10;    lines.append(&quot; SCHEDULE QUALITY REPORT&quot;)&#10;    lines.append(&quot;=&quot; * 50)&#10;    lines.append(f&quot;\n OVERALL SCORE: {report.overall_score:.1%}&quot;)&#10;    &#10;    # Quality level&#10;    if report.overall_score &gt;= 0.8:&#10;        lines.append(&quot; Quality Level: EXCELLENT&quot;)&#10;    elif report.overall_score &gt;= 0.6:&#10;        lines.append(&quot;✅ Quality Level: GOOD&quot;) &#10;    elif report.overall_score &gt;= 0.4:&#10;        lines.append(&quot;⚠️ Quality Level: FAIR&quot;)&#10;    else:&#10;        lines.append(&quot; Quality Level: POOR&quot;)&#10;    &#10;    # Detailed metrics&#10;    lines.append(f&quot;\n DETAILED METRICS&quot;)&#10;    lines.append(&quot;-&quot; * 30)&#10;    for metric in sorted(report.metrics, key=lambda x: x.score, reverse=True):&#10;        score_bar = &quot;█&quot; * int(metric.score * 10) + &quot;░&quot; * (10 - int(metric.score * 10))&#10;        lines.append(f&quot;{metric.name:20} [{score_bar}] {metric.score:.1%}&quot;)&#10;        lines.append(f&quot;{'':20} {metric.description}&quot;)&#10;        lines.append(&quot;&quot;)&#10;    &#10;    # Strengths&#10;    if report.strengths:&#10;        lines.append(&quot; STRENGTHS&quot;)&#10;        lines.append(&quot;-&quot; * 20)&#10;        for strength in report.strengths:&#10;            lines.append(f&quot;  {strength}&quot;)&#10;        lines.append(&quot;&quot;)&#10;    &#10;    # Weaknesses&#10;    if report.weaknesses:&#10;        lines.append(&quot;⚠️ AREAS FOR IMPROVEMENT&quot;)&#10;        lines.append(&quot;-&quot; * 30)&#10;        for weakness in report.weaknesses:&#10;            lines.append(f&quot;  {weakness}&quot;)&#10;        lines.append(&quot;&quot;)&#10;    &#10;    # Recommendations&#10;    if report.recommendations:&#10;        lines.append(&quot; RECOMMENDATIONS&quot;)&#10;        lines.append(&quot;-&quot; * 25)&#10;        for i, rec in enumerate(report.recommendations, 1):&#10;            lines.append(f&quot;{i}. {rec}&quot;)&#10;        lines.append(&quot;&quot;)&#10;    &#10;    return &quot;\n&quot;.join(lines)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>