<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/timetable_agent.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/timetable_agent.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Timetabling agent (feasible schedule) WITHOUT modifying problem_solving_agent.py.&#10;&#10;Weeks constraint (flexible):&#10;- Each Event has a set of active weeks: event.weeks (FrozenSet[int]).&#10;- A resource conflict (teacher/group/room) occurs only if:&#10;  same timeslot AND weeks sets intersect.&#10;&#10;Hard constraints:&#10;- teacher availability (weekly pattern) + no teacher conflict (weeks-aware)&#10;- group availability (weekly pattern) + no group conflict (weeks-aware)&#10;- room availability (weekly pattern) + no room conflict (weeks-aware)&#10;- room capacity &gt;= max(sum(group sizes), module min_room_capacity)&#10;- timeslot duration == event duration&#10;&#10;Input/Output handled by timetable_io.py (JSON v3 with weeks as list/ranges/all).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, FrozenSet, List, Optional, Tuple&#10;from collections import deque&#10;import heapq&#10;&#10;from problem_solving_agent import Problem&#10;&#10;# ==========================================================&#10;# Search trace / graph export (optional)&#10;# ==========================================================&#10;&#10;try:&#10;    from search_graph import SearchGraphRecorder&#10;except Exception:  # pragma: no cover&#10;    SearchGraphRecorder = None  # type: ignore&#10;&#10;&#10;# ==========================================================&#10;# Data model&#10;# ==========================================================&#10;&#10;@dataclass(frozen=True)&#10;class TimeSlot:&#10;    id: str&#10;    day: str&#10;    start: str&#10;    end: str&#10;    duration_min: int&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Group:&#10;    id: str&#10;    size: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Room:&#10;    id: str&#10;    capacity: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Teacher:&#10;    id: str&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Event:&#10;    id: str&#10;    teacher_id: str&#10;    group_ids: Tuple[str, ...]&#10;    duration_min: int&#10;    allowed_slots: Optional[FrozenSet[str]] = None&#10;&#10;    # From module/session structure (input JSON)&#10;    min_room_capacity: int = 0&#10;    session_id: str = &quot;&quot;&#10;    module_id: str = &quot;&quot;&#10;&#10;    # Module hours per week (informational, from module config)&#10;    module_hours_per_week: float = 0.0&#10;&#10;    # Active weeks for this event (e.g., {1,3,5} or weeks from ranges)&#10;    weeks: FrozenSet[int] = frozenset()&#10;&#10;&#10;# State: tuple of assignments (event_id, timeslot_id, room_id) sorted by event_id&#10;AssignmentTuple = Tuple[Tuple[str, str, str], ...]&#10;&#10;&#10;# ==========================================================&#10;# Weeks logic&#10;# ==========================================================&#10;&#10;def weeks_intersect(a: FrozenSet[int], b: FrozenSet[int]) -&gt; bool:&#10;    &quot;&quot;&quot;True if week sets intersect.&quot;&quot;&quot;&#10;    return not a.isdisjoint(b)&#10;&#10;&#10;# ==========================================================&#10;# Helpers&#10;# ==========================================================&#10;&#10;def event_demand(e: Event, groups: Dict[str, Group]) -&gt; int:&#10;    return sum(groups[gid].size for gid in e.group_ids)&#10;&#10;&#10;def is_room_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    r_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, r) in assignment:&#10;        if t != t_id or r != r_id:&#10;            continue&#10;        existing = events[eid]&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_teacher_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    teacher_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if existing.teacher_id != teacher_id:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_group_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    group_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if group_id not in existing.group_ids:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;# ==========================================================&#10;# Problem definition&#10;# ==========================================================&#10;&#10;class TimetablingProblem(Problem):&#10;    &quot;&quot;&quot;&#10;    Feasible scheduling problem with hard constraints only, using week-sets.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        initial_state: AssignmentTuple,&#10;        goal: Any = None,&#10;        *,&#10;        events: List[Event],&#10;        timeslots: List[TimeSlot],&#10;        rooms: List[Room],&#10;        teachers: List[Teacher],&#10;        groups: List[Group],&#10;        use_mrv: bool = True,&#10;    ):&#10;        super().__init__(initial_state, goal)&#10;&#10;        self.use_mrv = use_mrv&#10;&#10;        self.events_list = events&#10;        self.timeslots_list = timeslots&#10;        self.rooms_list = rooms&#10;        self.teachers_list = teachers&#10;        self.groups_list = groups&#10;&#10;        self.events: Dict[str, Event] = {e.id: e for e in events}&#10;        self.timeslots: Dict[str, TimeSlot] = {t.id: t for t in timeslots}&#10;        self.rooms: Dict[str, Room] = {r.id: r for r in rooms}&#10;        self.teachers: Dict[str, Teacher] = {t.id: t for t in teachers}&#10;        self.groups: Dict[str, Group] = {g.id: g for g in groups}&#10;&#10;        self.all_event_ids: Tuple[str, ...] = tuple(e.id for e in events)&#10;&#10;        # Precompute compatible rooms per event:&#10;        # room.capacity &gt;= max(demand, min_room_capacity)&#10;        self.compatible_rooms: Dict[str, Tuple[str, ...]] = {}&#10;        for e in events:&#10;            dem = event_demand(e, self.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            self.compatible_rooms[e.id] = tuple(r.id for r in rooms if r.capacity &gt;= required)&#10;&#10;        # Precompute compatible slots per event:&#10;        # duration + teacher availability + all groups availability (+ allowed_slots)&#10;        self.compatible_slots: Dict[str, Tuple[str, ...]] = {}&#10;        all_slot_ids = set(self.timeslots.keys())&#10;&#10;        for e in events:&#10;            duration_slots = {t.id for t in timeslots if t.duration_min == e.duration_min}&#10;            teacher_av = set(self.teachers[e.teacher_id].available)&#10;&#10;            group_av = set(all_slot_ids)&#10;            for gid in e.group_ids:&#10;                group_av &amp;= set(self.groups[gid].available)&#10;&#10;            slots = duration_slots &amp; teacher_av &amp; group_av&#10;&#10;            # Handle allowed_slots with support for ALL/all macro&#10;            if e.allowed_slots is not None:&#10;                allowed_set = set()&#10;                for slot in e.allowed_slots:&#10;                    if slot.upper() == &quot;ALL&quot;:&#10;                        # &quot;ALL&quot; or &quot;all&quot; means all available timeslots&#10;                        allowed_set = all_slot_ids&#10;                        break&#10;                    else:&#10;                        allowed_set.add(slot)&#10;                slots &amp;= allowed_set&#10;&#10;            self.compatible_slots[e.id] = tuple(sorted(slots))&#10;&#10;    def _unassigned(self, state: AssignmentTuple) -&gt; List[str]:&#10;        assigned = {eid for (eid, _, _) in state}&#10;        return [eid for eid in self.all_event_ids if eid not in assigned]&#10;&#10;    def _select_next_event(self, state: AssignmentTuple) -&gt; Optional[str]:&#10;        unassigned = self._unassigned(state)&#10;        if not unassigned:&#10;            return None&#10;&#10;        if not self.use_mrv:&#10;            return unassigned[0]&#10;&#10;        # MRV: smallest estimated domain size slots*rooms&#10;        best_eid = None&#10;        best_size = None&#10;        for eid in unassigned:&#10;            size = len(self.compatible_slots[eid]) * len(self.compatible_rooms[eid])&#10;            if best_eid is None or size &lt; best_size:&#10;                best_eid, best_size = eid, size&#10;        return best_eid&#10;&#10;    def actions(self, state: AssignmentTuple) -&gt; List[Tuple[str, str, str]]:&#10;        &quot;&quot;&quot;&#10;        Actions are (event_id, timeslot_id, room_id).&#10;        We generate actions only for the next event (MRV) to keep branching manageable.&#10;        &quot;&quot;&quot;&#10;        eid = self._select_next_event(state)&#10;        if eid is None:&#10;            return []&#10;&#10;        e = self.events[eid]&#10;        acts: List[Tuple[str, str, str]] = []&#10;&#10;        for t_id in self.compatible_slots[eid]:&#10;            # teacher conflict (weeks-aware)&#10;            if not is_teacher_free(state, self.events, t_id, e.teacher_id, e):&#10;                continue&#10;&#10;            # group conflicts (weeks-aware)&#10;            if any(not is_group_free(state, self.events, t_id, gid, e) for gid in e.group_ids):&#10;                continue&#10;&#10;            for r_id in self.compatible_rooms[eid]:&#10;                room = self.rooms[r_id]&#10;&#10;                # room availability (weekly pattern)&#10;                if t_id not in room.available:&#10;                    continue&#10;&#10;                # room conflict (weeks-aware)&#10;                if not is_room_free(state, self.events, t_id, r_id, e):&#10;                    continue&#10;&#10;                acts.append((eid, t_id, r_id))&#10;&#10;        return acts&#10;&#10;    def result(self, state: AssignmentTuple, action: Tuple[str, str, str]) -&gt; AssignmentTuple:&#10;        eid, t_id, r_id = action&#10;        new_state = list(state) + [(eid, t_id, r_id)]&#10;        new_state.sort(key=lambda x: x[0])  # canonical&#10;        return tuple(new_state)&#10;&#10;    def goal_test(self, state: AssignmentTuple) -&gt; bool:&#10;        return len(state) == len(self.all_event_ids)&#10;&#10;    def path_cost(self, cost_so_far: float, state1: Any, action: Any, state2: Any) -&gt; float:&#10;        return cost_so_far + 1.0&#10;&#10;&#10;# ==========================================================&#10;# Search algorithms (no Trace dependency)&#10;# ==========================================================&#10;&#10;import time&#10;&#10;@dataclass&#10;class SearchResult:&#10;    &quot;&quot;&quot;Result of a search algorithm with statistics.&quot;&quot;&quot;&#10;    path: Optional[List[Any]]&#10;    iterations: int&#10;    nodes_explored: int&#10;    max_frontier_size: int&#10;    final_cost: float&#10;    elapsed_time: float&#10;    algorithm: str&#10;&#10;&#10;def reconstruct_path(parents: Dict[Any, Any], start: Any, goal: Any) -&gt; List[Any]:&#10;    path = [goal]&#10;    cur = goal&#10;    while cur != start:&#10;        cur = parents[cur]&#10;        path.append(cur)&#10;    path.reverse()&#10;    return path&#10;&#10;&#10;def state_repr(state: AssignmentTuple, max_items: int = 3) -&gt; str:&#10;    &quot;&quot;&quot;Compact representation of state for console output.&quot;&quot;&quot;&#10;    if len(state) == 0:&#10;        return &quot;(empty)&quot;&#10;    if len(state) &lt;= max_items:&#10;        return str(list(state))&#10;    return f&quot;[{len(state)} assignments: {list(state[:max_items])}...]&quot;&#10;&#10;&#10;def dfs_search(&#10;    problem: TimetablingProblem,&#10;    verbose: bool = True,&#10;    *,&#10;    record_graph: bool = False,&#10;    algorithm_label: str = &quot;DFS&quot;,&#10;):&#10;    algo_name = algorithm_label&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = [start]&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set()&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    recorder = None&#10;    if record_graph:&#10;        if SearchGraphRecorder is None:&#10;            raise RuntimeError(&#10;                &quot;Graph recording requested but 'search_graph.py' could not be imported.&quot;&#10;            )&#10;        recorder = SearchGraphRecorder(algorithm=algo_name)&#10;        recorder.mark_start(start, label=f&quot;{state_repr(start)}\nstart&quot;)&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.pop()&#10;&#10;        actions_list = problem.actions(state)&#10;&#10;        if recorder is not None:&#10;            recorder.add_iteration(&#10;                iteration=iteration,&#10;                current_state=state,&#10;                frontier_size=len(frontier),&#10;                explored_size=len(visited),&#10;                cost=float(len(state)),&#10;                actions_count=len(actions_list),&#10;                current_label=f&quot;{state_repr(state)}\niter={iteration} f={len(frontier)} e={len(visited)}&quot;,&#10;            )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if recorder is not None:&#10;                recorder.mark_goal(state, label=f&quot;{state_repr(state)}\nGOAL&quot;)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            result = SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name,&#10;            )&#10;            # Attach recorder if present (non-breaking: just set attribute)&#10;            if recorder is not None:&#10;                setattr(result, &quot;graph&quot;, recorder)&#10;            return result&#10;&#10;        if state in visited:&#10;            continue&#10;        visited.add(state)&#10;&#10;        for action in actions_list:&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                parents[child] = state&#10;                frontier.append(child)&#10;                if recorder is not None:&#10;                    recorder.add_edge(&#10;                        state,&#10;                        child,&#10;                        parent_label=state_repr(state),&#10;                        child_label=state_repr(child),&#10;                        attrs={&quot;label&quot;: str(action)},&#10;                    )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(actions_list)}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    result = SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name,&#10;    )&#10;    if recorder is not None:&#10;        setattr(result, &quot;graph&quot;, recorder)&#10;    return result&#10;&#10;&#10;def bfs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;BFS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = deque([start])&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set([start])&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 1 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.popleft()&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                visited.add(child)&#10;                parents[child] = state&#10;                frontier.append(child)&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def ucs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;UCS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(0.0, start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        g, state = heapq.heappop(frontier)&#10;&#10;        if g != best_g.get(state, float(&quot;inf&quot;)):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g, child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def h_zero(state: AssignmentTuple) -&gt; float:&#10;    return 0.0&#10;&#10;&#10;def a_star_search(problem: TimetablingProblem, h=h_zero, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;A*&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(h(start), start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial g=0.0, h={h(start)}, f={h(start)}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        f, state = heapq.heappop(frontier)&#10;        g = best_g[state]&#10;&#10;        if f != g + h(state):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}, h(n): {h(state)}, f(n): {f}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g + h(child), child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;# ==========================================================&#10;# Output formatting&#10;# ==========================================================&#10;&#10;def _weeks_to_ranges(weeks: FrozenSet[int]) -&gt; str:&#10;    &quot;&quot;&quot;Compact printing: 1,3,5,7,10,16 or 1-6,10-14 style.&quot;&quot;&quot;&#10;    if not weeks:&#10;        return &quot;&quot;&#10;    w = sorted(weeks)&#10;    ranges = []&#10;    start = prev = w[0]&#10;    for x in w[1:]:&#10;        if x == prev + 1:&#10;            prev = x&#10;            continue&#10;        ranges.append((start, prev))&#10;        start = prev = x&#10;    ranges.append((start, prev))&#10;    return &quot;,&quot;.join([f&quot;{a}-{b}&quot; if a != b else f&quot;{a}&quot; for a, b in ranges])&#10;&#10;&#10;def pretty_print_schedule(problem: TimetablingProblem, assignment: AssignmentTuple):&#10;    print(&quot;\n================= SCHEDULE =================&quot;)&#10;&#10;    def key_fn(x):&#10;        eid, tid, _ = x&#10;        ts = problem.timeslots[tid]&#10;        return (ts.day, ts.start, eid)&#10;&#10;    for eid, tid, rid in sorted(assignment, key=key_fn):&#10;        e = problem.events[eid]&#10;        ts = problem.timeslots[tid]&#10;        dem = event_demand(e, problem.groups)&#10;        cap = problem.rooms[rid].capacity&#10;        required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;&#10;        print(&#10;            f&quot;- {ts.day} {ts.start}-{ts.end} | event={eid} | teacher={e.teacher_id} &quot;&#10;            f&quot;| groups={list(e.group_ids)} | room={rid} | required={required}/{cap} &quot;&#10;            f&quot;| weeks={_weeks_to_ranges(e.weeks)} | session={e.session_id} module={e.module_id}&quot;&#10;        )&#10;&#10;    print(&quot;===========================================\n&quot;)&#10;&#10;&#10;&#10;def diagnose_domains(problem: TimetablingProblem, limit: int = 50):&#10;    &quot;&quot;&quot;&#10;    Prints events that have 0 possible actions from the INITIAL state,&#10;    i.e. no (timeslot, room) satisfies availability + capacity constraints&#10;    (without considering conflicts with other events).&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n========== DIAGNOSE: INITIAL DOMAINS ==========&quot;)&#10;    bad = 0&#10;    for e in problem.events_list:&#10;        slots = problem.compatible_slots.get(e.id, ())&#10;        rooms = problem.compatible_rooms.get(e.id, ())&#10;        domain_size = len(slots) * len(rooms)&#10;        if domain_size == 0:&#10;            bad += 1&#10;            dem = event_demand(e, problem.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            print(f&quot;- EVENT {e.id} | teacher={e.teacher_id} | session={e.session_id} module={e.module_id}&quot;)&#10;            print(f&quot;  groups={list(e.group_ids)} demand={dem} min_room_capacity={e.min_room_capacity} required={required}&quot;)&#10;            print(f&quot;  compatible_slots={list(slots)}&quot;)&#10;            print(f&quot;  compatible_rooms={list(rooms)}&quot;)&#10;            if bad &gt;= limit:&#10;                print(f&quot;... (stopping after {limit} zero-domain events)&quot;)&#10;                break&#10;    if bad == 0:&#10;        print(&quot;✅ All events have a non-empty initial domain (before conflicts).&quot;)&#10;    else:&#10;        print(f&quot;❌ Found {bad} events with empty initial domain.&quot;)&#10;    print(&quot;=============================================\n&quot;)&#10;&#10;# ==========================================================&#10;# Main solve entry (JSON in/out)&#10;# ==========================================================&#10;&#10;def print_comparison_table(results: List[SearchResult]):&#10;    &quot;&quot;&quot;Print a comparison table of all search algorithms.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;  COMPARAISON DES ALGORITHMES DE RECHERCHE&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    print(f&quot;{'Algorithme':&lt;12} {'Statut':&lt;12} {'Itérations':&lt;12} {'Explorés':&lt;12} {'Max Frontière':&lt;15} {'Coût Final':&lt;12} {'Temps (s)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 100)&#10;&#10;    for r in results:&#10;        status = &quot;✅ Succès&quot; if r.path is not None else &quot;❌ Échec&quot;&#10;        cost_str = f&quot;{r.final_cost:.1f}&quot; if r.final_cost != float('inf') else &quot;∞&quot;&#10;        print(f&quot;{r.algorithm:&lt;12} {status:&lt;12} {r.iterations:&lt;12} {r.nodes_explored:&lt;12} {r.max_frontier_size:&lt;15} {cost_str:&lt;12} {r.elapsed_time:&lt;12.4f}&quot;)&#10;&#10;    print(&quot;=&quot; * 100)&#10;    print()&#10;&#10;&#10;def solve_from_json(input_path: str, output_path: str, compare_all: bool = True):&#10;    from timetable_io import load_input_json, export_output_json&#10;&#10;    config, problem = load_input_json(input_path)&#10;    diagnose_domains(problem)&#10;&#10;    if compare_all:&#10;        # Run all 4 algorithms and compare results&#10;        print(&quot;\n&quot; + &quot;#&quot; * 100)&#10;        print(&quot;  EXÉCUTION DE TOUS LES ALGORITHMES POUR COMPARAISON&quot;)&#10;        print(&quot;#&quot; * 100)&#10;&#10;        results: List[SearchResult] = []&#10;&#10;        # DFS&#10;        result_dfs = dfs_search(problem, verbose=True)&#10;        results.append(result_dfs)&#10;&#10;        # BFS&#10;        result_bfs = bfs_search(problem, verbose=True)&#10;        results.append(result_bfs)&#10;&#10;        # UCS&#10;        result_ucs = ucs_search(problem, verbose=True)&#10;        results.append(result_ucs)&#10;&#10;        # A*&#10;        result_astar = a_star_search(problem, h_zero, verbose=True)&#10;        results.append(result_astar)&#10;&#10;        # Print comparison table&#10;        print_comparison_table(results)&#10;&#10;        # Use first successful result for output&#10;        best_result = None&#10;        for r in results:&#10;            if r.path is not None:&#10;                best_result = r&#10;                break&#10;&#10;        if best_result is None:&#10;            print(&quot;❌ Aucun algorithme n'a trouvé de solution.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=&quot;compare_all&quot;,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = best_result.path[-1]&#10;        print(f&quot;✅ Meilleur résultat avec {best_result.algorithm}: {len(final_state)} événements planifiés&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=best_result.algorithm.lower(),&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;    else:&#10;        # Original behavior: run only the specified strategy&#10;        strategy = str(config.get(&quot;strategy&quot;, &quot;dfs&quot;)).lower()&#10;&#10;        if strategy == &quot;dfs&quot;:&#10;            result = dfs_search(problem, verbose=True)&#10;        elif strategy == &quot;bfs&quot;:&#10;            result = bfs_search(problem, verbose=True)&#10;        elif strategy == &quot;ucs&quot;:&#10;            result = ucs_search(problem, verbose=True)&#10;        elif strategy in (&quot;astar&quot;, &quot;a*&quot;, &quot;a_star&quot;):&#10;            result = a_star_search(problem, h_zero, verbose=True)&#10;            strategy = &quot;a_star&quot;&#10;        else:&#10;            raise ValueError(f&quot;Unknown strategy '{strategy}'. Use one of: dfs, bfs, ucs, astar&quot;)&#10;&#10;        if result.path is None:&#10;            print(&quot;❌ No feasible schedule found.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=strategy,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = result.path[-1]&#10;        print(f&quot;✅ Feasible schedule found. events_scheduled={len(final_state)}/{len(problem.events_list)}&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=strategy,&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    solve_from_json(&quot;test/09_real_world_scenario.json&quot;, &quot;timetable_output.json&quot;, compare_all=False)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Timetabling agent (feasible schedule) WITHOUT modifying problem_solving_agent.py.&#10;&#10;Weeks constraint (flexible):&#10;- Each Event has a set of active weeks: event.weeks (FrozenSet[int]).&#10;- A resource conflict (teacher/group/room) occurs only if:&#10;  same timeslot AND weeks sets intersect.&#10;&#10;Hard constraints:&#10;- teacher availability (weekly pattern) + no teacher conflict (weeks-aware)&#10;- group availability (weekly pattern) + no group conflict (weeks-aware)&#10;- room availability (weekly pattern) + no room conflict (weeks-aware)&#10;- room capacity &gt;= max(sum(group sizes), module min_room_capacity)&#10;- timeslot duration == event duration&#10;&#10;Input/Output handled by timetable_io.py (JSON v3 with weeks as list/ranges/all).&#10;&quot;&quot;&quot;&#10;&#10;from __future__ import annotations&#10;&#10;from dataclasses import dataclass&#10;from typing import Any, Dict, FrozenSet, List, Optional, Tuple&#10;from collections import deque&#10;import heapq&#10;&#10;from problem_solving_agent import Problem&#10;&#10;# ==========================================================&#10;# Search trace / graph export (optional)&#10;# ==========================================================&#10;&#10;try:&#10;    from search_graph import SearchGraphRecorder&#10;except Exception:  # pragma: no cover&#10;    SearchGraphRecorder = None  # type: ignore&#10;&#10;&#10;# ==========================================================&#10;# Data model&#10;# ==========================================================&#10;&#10;@dataclass(frozen=True)&#10;class TimeSlot:&#10;    id: str&#10;    day: str&#10;    start: str&#10;    end: str&#10;    duration_min: int&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Group:&#10;    id: str&#10;    size: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Room:&#10;    id: str&#10;    capacity: int&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Teacher:&#10;    id: str&#10;    available: FrozenSet[str]  # timeslot ids (weekly pattern)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class Event:&#10;    id: str&#10;    teacher_id: str&#10;    group_ids: Tuple[str, ...]&#10;    duration_min: int&#10;    allowed_slots: Optional[FrozenSet[str]] = None&#10;&#10;    # From module/session structure (input JSON)&#10;    min_room_capacity: int = 0&#10;    session_id: str = &quot;&quot;&#10;    module_id: str = &quot;&quot;&#10;&#10;    # Module hours per week (informational, from module config)&#10;    module_hours_per_week: float = 0.0&#10;&#10;    # Active weeks for this event (e.g., {1,3,5} or weeks from ranges)&#10;    weeks: FrozenSet[int] = frozenset()&#10;&#10;&#10;# State: tuple of assignments (event_id, timeslot_id, room_id) sorted by event_id&#10;AssignmentTuple = Tuple[Tuple[str, str, str], ...]&#10;&#10;&#10;# ==========================================================&#10;# Weeks logic&#10;# ==========================================================&#10;&#10;def weeks_intersect(a: FrozenSet[int], b: FrozenSet[int]) -&gt; bool:&#10;    &quot;&quot;&quot;True if week sets intersect.&quot;&quot;&quot;&#10;    return not a.isdisjoint(b)&#10;&#10;&#10;# ==========================================================&#10;# Helpers&#10;# ==========================================================&#10;&#10;def event_demand(e: Event, groups: Dict[str, Group]) -&gt; int:&#10;    return sum(groups[gid].size for gid in e.group_ids)&#10;&#10;&#10;def is_room_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    r_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, r) in assignment:&#10;        if t != t_id or r != r_id:&#10;            continue&#10;        existing = events[eid]&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_teacher_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    teacher_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if existing.teacher_id != teacher_id:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;def is_group_free(&#10;    assignment: AssignmentTuple,&#10;    events: Dict[str, Event],&#10;    t_id: str,&#10;    group_id: str,&#10;    candidate: Event,&#10;) -&gt; bool:&#10;    for (eid, t, _) in assignment:&#10;        if t != t_id:&#10;            continue&#10;        existing = events[eid]&#10;        if group_id not in existing.group_ids:&#10;            continue&#10;        if weeks_intersect(existing.weeks, candidate.weeks):&#10;            return False&#10;    return True&#10;&#10;&#10;# ==========================================================&#10;# Problem definition&#10;# ==========================================================&#10;&#10;class TimetablingProblem(Problem):&#10;    &quot;&quot;&quot;&#10;    Feasible scheduling problem with hard constraints only, using week-sets.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        initial_state: AssignmentTuple,&#10;        goal: Any = None,&#10;        *,&#10;        events: List[Event],&#10;        timeslots: List[TimeSlot],&#10;        rooms: List[Room],&#10;        teachers: List[Teacher],&#10;        groups: List[Group],&#10;        use_mrv: bool = True,&#10;    ):&#10;        super().__init__(initial_state, goal)&#10;&#10;        self.use_mrv = use_mrv&#10;&#10;        self.events_list = events&#10;        self.timeslots_list = timeslots&#10;        self.rooms_list = rooms&#10;        self.teachers_list = teachers&#10;        self.groups_list = groups&#10;&#10;        self.events: Dict[str, Event] = {e.id: e for e in events}&#10;        self.timeslots: Dict[str, TimeSlot] = {t.id: t for t in timeslots}&#10;        self.rooms: Dict[str, Room] = {r.id: r for r in rooms}&#10;        self.teachers: Dict[str, Teacher] = {t.id: t for t in teachers}&#10;        self.groups: Dict[str, Group] = {g.id: g for g in groups}&#10;&#10;        self.all_event_ids: Tuple[str, ...] = tuple(e.id for e in events)&#10;&#10;        # Precompute compatible rooms per event:&#10;        # room.capacity &gt;= max(demand, min_room_capacity)&#10;        self.compatible_rooms: Dict[str, Tuple[str, ...]] = {}&#10;        for e in events:&#10;            dem = event_demand(e, self.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            self.compatible_rooms[e.id] = tuple(r.id for r in rooms if r.capacity &gt;= required)&#10;&#10;        # Precompute compatible slots per event:&#10;        # duration + teacher availability + all groups availability (+ allowed_slots)&#10;        self.compatible_slots: Dict[str, Tuple[str, ...]] = {}&#10;        all_slot_ids = set(self.timeslots.keys())&#10;&#10;        for e in events:&#10;            duration_slots = {t.id for t in timeslots if t.duration_min == e.duration_min}&#10;            teacher_av = set(self.teachers[e.teacher_id].available)&#10;&#10;            group_av = set(all_slot_ids)&#10;            for gid in e.group_ids:&#10;                group_av &amp;= set(self.groups[gid].available)&#10;&#10;            slots = duration_slots &amp; teacher_av &amp; group_av&#10;&#10;            # Handle allowed_slots with support for ALL/all macro&#10;            if e.allowed_slots is not None:&#10;                allowed_set = set()&#10;                for slot in e.allowed_slots:&#10;                    if slot.upper() == &quot;ALL&quot;:&#10;                        # &quot;ALL&quot; or &quot;all&quot; means all available timeslots&#10;                        allowed_set = all_slot_ids&#10;                        break&#10;                    else:&#10;                        allowed_set.add(slot)&#10;                slots &amp;= allowed_set&#10;&#10;            self.compatible_slots[e.id] = tuple(sorted(slots))&#10;&#10;    def _unassigned(self, state: AssignmentTuple) -&gt; List[str]:&#10;        assigned = {eid for (eid, _, _) in state}&#10;        return [eid for eid in self.all_event_ids if eid not in assigned]&#10;&#10;    def _select_next_event(self, state: AssignmentTuple) -&gt; Optional[str]:&#10;        unassigned = self._unassigned(state)&#10;        if not unassigned:&#10;            return None&#10;&#10;        if not self.use_mrv:&#10;            return unassigned[0]&#10;&#10;        # MRV: smallest estimated domain size slots*rooms&#10;        best_eid = None&#10;        best_size = None&#10;        for eid in unassigned:&#10;            size = len(self.compatible_slots[eid]) * len(self.compatible_rooms[eid])&#10;            if best_eid is None or size &lt; best_size:&#10;                best_eid, best_size = eid, size&#10;        return best_eid&#10;&#10;    def actions(self, state: AssignmentTuple) -&gt; List[Tuple[str, str, str]]:&#10;        &quot;&quot;&quot;&#10;        Actions are (event_id, timeslot_id, room_id).&#10;        We generate actions only for the next event (MRV) to keep branching manageable.&#10;        &quot;&quot;&quot;&#10;        eid = self._select_next_event(state)&#10;        if eid is None:&#10;            return []&#10;&#10;        e = self.events[eid]&#10;        acts: List[Tuple[str, str, str]] = []&#10;&#10;        for t_id in self.compatible_slots[eid]:&#10;            # teacher conflict (weeks-aware)&#10;            if not is_teacher_free(state, self.events, t_id, e.teacher_id, e):&#10;                continue&#10;&#10;            # group conflicts (weeks-aware)&#10;            if any(not is_group_free(state, self.events, t_id, gid, e) for gid in e.group_ids):&#10;                continue&#10;&#10;            for r_id in self.compatible_rooms[eid]:&#10;                room = self.rooms[r_id]&#10;&#10;                # room availability (weekly pattern)&#10;                if t_id not in room.available:&#10;                    continue&#10;&#10;                # room conflict (weeks-aware)&#10;                if not is_room_free(state, self.events, t_id, r_id, e):&#10;                    continue&#10;&#10;                acts.append((eid, t_id, r_id))&#10;&#10;        return acts&#10;&#10;    def result(self, state: AssignmentTuple, action: Tuple[str, str, str]) -&gt; AssignmentTuple:&#10;        eid, t_id, r_id = action&#10;        new_state = list(state) + [(eid, t_id, r_id)]&#10;        new_state.sort(key=lambda x: x[0])  # canonical&#10;        return tuple(new_state)&#10;&#10;    def goal_test(self, state: AssignmentTuple) -&gt; bool:&#10;        return len(state) == len(self.all_event_ids)&#10;&#10;    def path_cost(self, cost_so_far: float, state1: Any, action: Any, state2: Any) -&gt; float:&#10;        return cost_so_far + 1.0&#10;&#10;&#10;# ==========================================================&#10;# Search algorithms (no Trace dependency)&#10;# ==========================================================&#10;&#10;import time&#10;&#10;@dataclass&#10;class SearchResult:&#10;    &quot;&quot;&quot;Result of a search algorithm with statistics.&quot;&quot;&quot;&#10;    path: Optional[List[Any]]&#10;    iterations: int&#10;    nodes_explored: int&#10;    max_frontier_size: int&#10;    final_cost: float&#10;    elapsed_time: float&#10;    algorithm: str&#10;&#10;&#10;def reconstruct_path(parents: Dict[Any, Any], start: Any, goal: Any) -&gt; List[Any]:&#10;    path = [goal]&#10;    cur = goal&#10;    while cur != start:&#10;        cur = parents[cur]&#10;        path.append(cur)&#10;    path.reverse()&#10;    return path&#10;&#10;&#10;def state_repr(state: AssignmentTuple, max_items: int = 3) -&gt; str:&#10;    &quot;&quot;&quot;Compact representation of state for console output.&quot;&quot;&quot;&#10;    if len(state) == 0:&#10;        return &quot;(empty)&quot;&#10;    if len(state) &lt;= max_items:&#10;        return str(list(state))&#10;    return f&quot;[{len(state)} assignments: {list(state[:max_items])}...]&quot;&#10;&#10;&#10;def dfs_search(&#10;    problem: TimetablingProblem,&#10;    verbose: bool = True,&#10;    *,&#10;    record_graph: bool = False,&#10;    algorithm_label: str = &quot;DFS&quot;,&#10;):&#10;    algo_name = algorithm_label&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = [start]&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set()&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    recorder = None&#10;    if record_graph:&#10;        if SearchGraphRecorder is None:&#10;            raise RuntimeError(&#10;                &quot;Graph recording requested but 'search_graph.py' could not be imported.&quot;&#10;            )&#10;        recorder = SearchGraphRecorder(algorithm=algo_name)&#10;        recorder.mark_start(start, label=f&quot;{state_repr(start)}\nstart&quot;)&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.pop()&#10;&#10;        actions_list = problem.actions(state)&#10;&#10;        if recorder is not None:&#10;            recorder.add_iteration(&#10;                iteration=iteration,&#10;                current_state=state,&#10;                frontier_size=len(frontier),&#10;                explored_size=len(visited),&#10;                cost=float(len(state)),&#10;                actions_count=len(actions_list),&#10;                current_label=f&quot;{state_repr(state)}\niter={iteration} f={len(frontier)} e={len(visited)}&quot;,&#10;            )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if recorder is not None:&#10;                recorder.mark_goal(state, label=f&quot;{state_repr(state)}\nGOAL&quot;)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            result = SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name,&#10;            )&#10;            # Attach recorder if present (non-breaking: just set attribute)&#10;            if recorder is not None:&#10;                setattr(result, &quot;graph&quot;, recorder)&#10;            return result&#10;&#10;        if state in visited:&#10;            continue&#10;        visited.add(state)&#10;&#10;        for action in actions_list:&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                parents[child] = state&#10;                frontier.append(child)&#10;                if recorder is not None:&#10;                    recorder.add_edge(&#10;                        state,&#10;                        child,&#10;                        parent_label=state_repr(state),&#10;                        child_label=state_repr(child),&#10;                        attrs={&quot;label&quot;: str(action)},&#10;                    )&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(actions_list)}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    result = SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name,&#10;    )&#10;    if recorder is not None:&#10;        setattr(result, &quot;graph&quot;, recorder)&#10;    return result&#10;&#10;&#10;def bfs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;BFS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier = deque([start])&#10;    parents: Dict[Any, Any] = {}&#10;    visited = set([start])&#10;    iteration = 0&#10;    max_frontier = 1&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 1 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        state = frontier.popleft()&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {len(visited)}&quot;)&#10;            print(f&quot;  Coût: {len(state)}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {len(state)}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=len(visited),&#10;                max_frontier_size=max_frontier,&#10;                final_cost=float(len(state)),&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            if child not in visited:&#10;                visited.add(child)&#10;                parents[child] = state&#10;                frontier.append(child)&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=len(visited),&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def ucs_search(problem: TimetablingProblem, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;UCS&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(0.0, start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial: 0.0&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        g, state = heapq.heappop(frontier)&#10;&#10;        if g != best_g.get(state, float(&quot;inf&quot;)):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g, child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;def h_zero(state: AssignmentTuple) -&gt; float:&#10;    return 0.0&#10;&#10;&#10;def a_star_search(problem: TimetablingProblem, h=h_zero, verbose: bool = True) -&gt; SearchResult:&#10;    algo_name = &quot;A*&quot;&#10;    start_time = time.time()&#10;    start = problem.initial_state&#10;    frontier: List[Tuple[float, Any]] = [(h(start), start)]&#10;    parents: Dict[Any, Any] = {}&#10;    best_g: Dict[Any, float] = {start: 0.0}&#10;    iteration = 0&#10;    max_frontier = 1&#10;    explored_count = 0&#10;&#10;    if verbose:&#10;        print(f&quot;\n{'='*60}&quot;)&#10;        print(f&quot;  ALGORITHME: {algo_name}&quot;)&#10;        print(f&quot;{'='*60}&quot;)&#10;        print(f&quot;État initial: {state_repr(start)}&quot;)&#10;        print(f&quot;Frontière initiale: taille={len(frontier)}&quot;)&#10;        print(f&quot;Explorés: 0 | Coût initial g=0.0, h={h(start)}, f={h(start)}&quot;)&#10;        print(&quot;-&quot; * 60)&#10;&#10;    while frontier:&#10;        iteration += 1&#10;        max_frontier = max(max_frontier, len(frontier))&#10;        f, state = heapq.heappop(frontier)&#10;        g = best_g[state]&#10;&#10;        if f != g + h(state):&#10;            continue&#10;&#10;        explored_count += 1&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;Itération {iteration}:&quot;)&#10;            print(f&quot;  État courant: {state_repr(state)}&quot;)&#10;            print(f&quot;  Frontière: {len(frontier)} états&quot;)&#10;            print(f&quot;  Explorés: {explored_count}&quot;)&#10;            print(f&quot;  Coût g(n): {g}, h(n): {h(state)}, f(n): {f}&quot;)&#10;&#10;        if problem.goal_test(state):&#10;            elapsed = time.time() - start_time&#10;            path = reconstruct_path(parents, start, state)&#10;            if verbose:&#10;                print(f&quot;\n✅ SOLUTION TROUVÉE à l'itération {iteration}&quot;)&#10;                print(f&quot;  Coût final: {g}&quot;)&#10;            return SearchResult(&#10;                path=path,&#10;                iterations=iteration,&#10;                nodes_explored=explored_count,&#10;                max_frontier_size=max_frontier,&#10;                final_cost=g,&#10;                elapsed_time=elapsed,&#10;                algorithm=algo_name&#10;            )&#10;&#10;        for action in problem.actions(state):&#10;            child = problem.result(state, action)&#10;            new_g = problem.path_cost(g, state, action, child)&#10;            if new_g &lt; best_g.get(child, float(&quot;inf&quot;)):&#10;                best_g[child] = new_g&#10;                parents[child] = state&#10;                heapq.heappush(frontier, (new_g + h(child), child))&#10;&#10;        if verbose and iteration &lt;= 10:&#10;            print(f&quot;  Actions possibles: {len(problem.actions(state))}&quot;)&#10;            print(&quot;-&quot; * 60)&#10;        elif verbose and iteration == 11:&#10;            print(&quot;... (affichage des itérations suivantes omis)&quot;)&#10;&#10;    elapsed = time.time() - start_time&#10;    if verbose:&#10;        print(f&quot;\n❌ Aucune solution trouvée après {iteration} itérations&quot;)&#10;    return SearchResult(&#10;        path=None,&#10;        iterations=iteration,&#10;        nodes_explored=explored_count,&#10;        max_frontier_size=max_frontier,&#10;        final_cost=float('inf'),&#10;        elapsed_time=elapsed,&#10;        algorithm=algo_name&#10;    )&#10;&#10;&#10;# ==========================================================&#10;# Output formatting&#10;# ==========================================================&#10;&#10;def _weeks_to_ranges(weeks: FrozenSet[int]) -&gt; str:&#10;    &quot;&quot;&quot;Compact printing: 1,3,5,7,10,16 or 1-6,10-14 style.&quot;&quot;&quot;&#10;    if not weeks:&#10;        return &quot;&quot;&#10;    w = sorted(weeks)&#10;    ranges = []&#10;    start = prev = w[0]&#10;    for x in w[1:]:&#10;        if x == prev + 1:&#10;            prev = x&#10;            continue&#10;        ranges.append((start, prev))&#10;        start = prev = x&#10;    ranges.append((start, prev))&#10;    return &quot;,&quot;.join([f&quot;{a}-{b}&quot; if a != b else f&quot;{a}&quot; for a, b in ranges])&#10;&#10;&#10;def pretty_print_schedule(problem: TimetablingProblem, assignment: AssignmentTuple):&#10;    print(&quot;\n================= SCHEDULE =================&quot;)&#10;&#10;    def key_fn(x):&#10;        eid, tid, _ = x&#10;        ts = problem.timeslots[tid]&#10;        return (ts.day, ts.start, eid)&#10;&#10;    for eid, tid, rid in sorted(assignment, key=key_fn):&#10;        e = problem.events[eid]&#10;        ts = problem.timeslots[tid]&#10;        dem = event_demand(e, problem.groups)&#10;        cap = problem.rooms[rid].capacity&#10;        required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;&#10;        print(&#10;            f&quot;- {ts.day} {ts.start}-{ts.end} | event={eid} | teacher={e.teacher_id} &quot;&#10;            f&quot;| groups={list(e.group_ids)} | room={rid} | required={required}/{cap} &quot;&#10;            f&quot;| weeks={_weeks_to_ranges(e.weeks)} | session={e.session_id} module={e.module_id}&quot;&#10;        )&#10;&#10;    print(&quot;===========================================\n&quot;)&#10;&#10;&#10;&#10;def diagnose_domains(problem: TimetablingProblem, limit: int = 50):&#10;    &quot;&quot;&quot;&#10;    Prints events that have 0 possible actions from the INITIAL state,&#10;    i.e. no (timeslot, room) satisfies availability + capacity constraints&#10;    (without considering conflicts with other events).&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n========== DIAGNOSE: INITIAL DOMAINS ==========&quot;)&#10;    bad = 0&#10;    for e in problem.events_list:&#10;        slots = problem.compatible_slots.get(e.id, ())&#10;        rooms = problem.compatible_rooms.get(e.id, ())&#10;        domain_size = len(slots) * len(rooms)&#10;        if domain_size == 0:&#10;            bad += 1&#10;            dem = event_demand(e, problem.groups)&#10;            required = max(dem, int(getattr(e, &quot;min_room_capacity&quot;, 0)))&#10;            print(f&quot;- EVENT {e.id} | teacher={e.teacher_id} | session={e.session_id} module={e.module_id}&quot;)&#10;            print(f&quot;  groups={list(e.group_ids)} demand={dem} min_room_capacity={e.min_room_capacity} required={required}&quot;)&#10;            print(f&quot;  compatible_slots={list(slots)}&quot;)&#10;            print(f&quot;  compatible_rooms={list(rooms)}&quot;)&#10;            if bad &gt;= limit:&#10;                print(f&quot;... (stopping after {limit} zero-domain events)&quot;)&#10;                break&#10;    if bad == 0:&#10;        print(&quot;✅ All events have a non-empty initial domain (before conflicts).&quot;)&#10;    else:&#10;        print(f&quot;❌ Found {bad} events with empty initial domain.&quot;)&#10;    print(&quot;=============================================\n&quot;)&#10;&#10;# ==========================================================&#10;# Main solve entry (JSON in/out)&#10;# ==========================================================&#10;&#10;def _generate_html_timetable(json_path: str, config: Dict[str, Any]):&#10;    &quot;&quot;&quot;Generate HTML timetable automatically after JSON export.&quot;&quot;&quot;&#10;    try:&#10;        from timetable_export import load_output_json, generate_html_timetable&#10;        import os&#10;        &#10;        # Generate HTML filename from JSON filename&#10;        base_name = os.path.splitext(json_path)[0]&#10;        html_path = f&quot;{base_name}.html&quot;&#10;        &#10;        # Load the JSON data&#10;        data = load_output_json(json_path)&#10;        &#10;        # Generate HTML timetable&#10;        generate_html_timetable(data, html_path)&#10;        &#10;        print(f&quot; Auto-generated HTML: {html_path}&quot;)&#10;        print(&quot;    Open the HTML file in a browser to view the visual timetable.&quot;)&#10;        &#10;        # Check if we have multiple sessions, offer session-based export&#10;        assignments = data.get(&quot;assignments&quot;, [])&#10;        sessions = set(a.get(&quot;session_id&quot;, &quot;unknown&quot;) for a in assignments)&#10;        &#10;        if len(sessions) &gt; 1:&#10;            print(f&quot;    Multiple sessions detected ({len(sessions)} sessions)&quot;)&#10;            print(f&quot;    Run: python timetable_export.py {json_path} --by-session&quot;)&#10;            print(&quot;      to generate separate timetables per session.&quot;)&#10;            &#10;    except Exception as e:&#10;        print(f&quot;⚠️  Failed to generate HTML: {e}&quot;)&#10;        print(&quot;   You can manually generate it with:&quot;)&#10;        print(f&quot;   python timetable_export.py {json_path}&quot;)&#10;&#10;&#10;def print_comparison_table(results: List[SearchResult]):&#10;    &quot;&quot;&quot;Print a comparison table of all search algorithms.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 100)&#10;    print(&quot;  COMPARAISON DES ALGORITHMES DE RECHERCHE&quot;)&#10;    print(&quot;=&quot; * 100)&#10;    print(f&quot;{'Algorithme':&lt;12} {'Statut':&lt;12} {'Itérations':&lt;12} {'Explorés':&lt;12} {'Max Frontière':&lt;15} {'Coût Final':&lt;12} {'Temps (s)':&lt;12}&quot;)&#10;    print(&quot;-&quot; * 100)&#10;&#10;    for r in results:&#10;        status = &quot;✅ Succès&quot; if r.path is not None else &quot;❌ Échec&quot;&#10;        cost_str = f&quot;{r.final_cost:.1f}&quot; if r.final_cost != float('inf') else &quot;∞&quot;&#10;        print(f&quot;{r.algorithm:&lt;12} {status:&lt;12} {r.iterations:&lt;12} {r.nodes_explored:&lt;12} {r.max_frontier_size:&lt;15} {cost_str:&lt;12} {r.elapsed_time:&lt;12.4f}&quot;)&#10;&#10;    print(&quot;=&quot; * 100)&#10;    print()&#10;&#10;&#10;def solve_from_json(input_path: str, output_path: str, compare_all: bool = True):&#10;    from timetable_io import load_input_json, export_output_json&#10;    import os&#10;&#10;    config, problem = load_input_json(input_path)&#10;    diagnose_domains(problem)&#10;&#10;    if compare_all:&#10;        # Run all 4 algorithms and compare results&#10;        print(&quot;\n&quot; + &quot;#&quot; * 100)&#10;        print(&quot;  EXÉCUTION DE TOUS LES ALGORITHMES POUR COMPARAISON&quot;)&#10;        print(&quot;#&quot; * 100)&#10;&#10;        results: List[SearchResult] = []&#10;&#10;        # DFS&#10;        result_dfs = dfs_search(problem, verbose=True)&#10;        results.append(result_dfs)&#10;&#10;        # BFS&#10;        result_bfs = bfs_search(problem, verbose=True)&#10;        results.append(result_bfs)&#10;&#10;        # UCS&#10;        result_ucs = ucs_search(problem, verbose=True)&#10;        results.append(result_ucs)&#10;&#10;        # A*&#10;        result_astar = a_star_search(problem, h_zero, verbose=True)&#10;        results.append(result_astar)&#10;&#10;        # Print comparison table&#10;        print_comparison_table(results)&#10;&#10;        # Use first successful result for output&#10;        best_result = None&#10;        for r in results:&#10;            if r.path is not None:&#10;                best_result = r&#10;                break&#10;&#10;        if best_result is None:&#10;            print(&quot;❌ Aucun algorithme n'a trouvé de solution.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=&quot;compare_all&quot;,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = best_result.path[-1]&#10;        print(f&quot;✅ Meilleur résultat avec {best_result.algorithm}: {len(final_state)} événements planifiés&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=best_result.algorithm.lower(),&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        _generate_html_timetable(output_path, config)&#10;&#10;    else:&#10;        # Original behavior: run only the specified strategy&#10;        strategy = str(config.get(&quot;strategy&quot;, &quot;dfs&quot;)).lower()&#10;&#10;        if strategy == &quot;dfs&quot;:&#10;            result = dfs_search(problem, verbose=True)&#10;        elif strategy == &quot;bfs&quot;:&#10;            result = bfs_search(problem, verbose=True)&#10;        elif strategy == &quot;ucs&quot;:&#10;            result = ucs_search(problem, verbose=True)&#10;        elif strategy in (&quot;astar&quot;, &quot;a*&quot;, &quot;a_star&quot;):&#10;            result = a_star_search(problem, h_zero, verbose=True)&#10;            strategy = &quot;a_star&quot;&#10;        else:&#10;            raise ValueError(f&quot;Unknown strategy '{strategy}'. Use one of: dfs, bfs, ucs, astar&quot;)&#10;&#10;        if result.path is None:&#10;            print(&quot;❌ No feasible schedule found.&quot;)&#10;            export_output_json(&#10;                output_path,&#10;                config=config,&#10;                problem=problem,&#10;                final_state=None,&#10;                status=&quot;failure&quot;,&#10;                strategy=strategy,&#10;            )&#10;            return&#10;&#10;        final_state: AssignmentTuple = result.path[-1]&#10;        print(f&quot;✅ Feasible schedule found. events_scheduled={len(final_state)}/{len(problem.events_list)}&quot;)&#10;        pretty_print_schedule(problem, final_state)&#10;&#10;        export_output_json(&#10;            output_path,&#10;            config=config,&#10;            problem=problem,&#10;            final_state=final_state,&#10;            status=&quot;success&quot;,&#10;            strategy=strategy,&#10;        )&#10;        print(f&quot; Exported JSON: {output_path}&quot;)&#10;&#10;        # Auto-generate HTML timetable&#10;        _generate_html_timetable(output_path, config)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    solve_from_json(&quot;test/09_real_world_scenario.json&quot;, &quot;timetable_output.json&quot;, compare_all=False)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>